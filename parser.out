Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> init
Rule 1     init -> program
Rule 2     program -> program class
Rule 3     program -> class
Rule 4     class -> field
Rule 5     class -> method
Rule 6     class -> CLASS error
Rule 7     class -> expression
Rule 8     class -> TYPE_IDENTIFIER
Rule 9     class -> block
Rule 10    class -> CLASS new_class_scope class-body
Rule 11    class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body
Rule 12    new_class_scope -> TYPE_IDENTIFIER
Rule 13    class-body -> LBRACE class-body-in RBRACE
Rule 14    class-body -> LBRACE class-body-in error
Rule 15    class-body-in -> class-body-in field
Rule 16    class-body-in -> class-body-in method
Rule 17    class-body-in -> <empty>
Rule 18    field -> OBJECT_IDENTIFIER COLON type SEMICOLON
Rule 19    field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON
Rule 20    method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block
Rule 21    new_variables_scope -> <empty>
Rule 22    type -> TYPE_IDENTIFIER
Rule 23    type -> INT32
Rule 24    type -> BOOL
Rule 25    type -> STRING
Rule 26    type -> UNIT
Rule 27    formals -> formal
Rule 28    formals -> formals COMMA formal
Rule 29    formals -> <empty>
Rule 30    formal -> OBJECT_IDENTIFIER COLON type
Rule 31    block -> LBRACE new_variables_scope inblock RBRACE
Rule 32    inblock -> inblock SEMICOLON expression
Rule 33    inblock -> expression
Rule 34    inblock -> <empty>
Rule 35    inblock -> inblock error
Rule 36    expression -> new_variables_scope IF expression THEN expression
Rule 37    expression -> new_variables_scope IF expression THEN expression ELSE expression
Rule 38    expression -> WHILE expression DO expression
Rule 39    expression -> LET let_type IN expression
Rule 40    expression -> LET let_type ASSIGN expression IN expression
Rule 41    let_type -> OBJECT_IDENTIFIER COLON type
Rule 42    expression -> OBJECT_IDENTIFIER ASSIGN get_type expression
Rule 43    get_type -> <empty>
Rule 44    expression -> NOT expression
Rule 45    expression -> MINUS expression
Rule 46    expression -> ISNULL expression
Rule 47    expression -> expression PLUS expression
Rule 48    expression -> expression MINUS expression
Rule 49    expression -> expression TIMES expression
Rule 50    expression -> expression DIV expression
Rule 51    expression -> expression EQUAL expression
Rule 52    expression -> expression LOWER_EQUAL expression
Rule 53    expression -> expression LOWER expression
Rule 54    expression -> expression POW expression
Rule 55    expression -> expression AND expression
Rule 56    expression -> OBJECT_IDENTIFIER LPAR args RPAR
Rule 57    expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR
Rule 58    expression -> NEW TYPE_IDENTIFIER
Rule 59    expression -> OBJECT_IDENTIFIER
Rule 60    expression -> SELF
Rule 61    expression -> literal
Rule 62    expression -> LPAR RPAR
Rule 63    expression -> LPAR expression RPAR
Rule 64    expression -> LPAR expression error
Rule 65    expression -> error expression RPAR
Rule 66    expression -> block
Rule 67    expression -> error
Rule 68    expression -> IF expression THEN expression SEMICOLON error
Rule 69    args -> args COMMA expression
Rule 70    args -> expression
Rule 71    args -> <empty>
Rule 72    literal -> literal_integer
Rule 73    literal -> literal_string
Rule 74    literal -> boolean-literal
Rule 75    literal_string -> string_literal
Rule 76    literal_integer -> INTEGER_LITERAL
Rule 77    boolean-literal -> TRUE
Rule 78    boolean-literal -> FALSE

Terminals, with rules where they appear

AND                  : 55
ASSIGN               : 19 40 42
BOOL                 : 24
CLASS                : 6 10 11
COLON                : 18 19 20 30 41
COMMA                : 28 69
DIV                  : 50
DO                   : 38
DOT                  : 57
ELSE                 : 37
EQUAL                : 51
EXTENDS              : 11
FALSE                : 78
IF                   : 36 37 68
IN                   : 39 40
INT32                : 23
INTEGER_LITERAL      : 76
ISNULL               : 46
LBRACE               : 13 14 31
LET                  : 39 40
LOWER                : 53
LOWER_EQUAL          : 52
LPAR                 : 20 56 57 62 63 64
MINUS                : 45 48
NEW                  : 58
NOT                  : 44
OBJECT_IDENTIFIER    : 18 19 20 30 41 42 56 57 59
PLUS                 : 47
POW                  : 54
RBRACE               : 13 31
RPAR                 : 20 56 57 62 63 65
SELF                 : 60
SEMICOLON            : 18 19 32 68
STRING               : 25
THEN                 : 36 37 68
TIMES                : 49
TRUE                 : 77
TYPE_IDENTIFIER      : 8 11 12 22 58
UNIT                 : 26
WHILE                : 38
error                : 6 14 35 64 65 67 68
string_literal       : 75

Nonterminals, with rules where they appear

args                 : 56 57 69
block                : 9 20 66
boolean-literal      : 74
class                : 2 3
class-body           : 10 11
class-body-in        : 13 14 15 16
expression           : 7 19 32 33 36 36 37 37 37 38 38 39 40 40 42 44 45 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 57 63 64 65 68 68 69 70
field                : 4 15
formal               : 27 28
formals              : 20 28
get_type             : 42
inblock              : 31 32 35
init                 : 0
let_type             : 39 40
literal              : 61
literal_integer      : 72
literal_string       : 73
method               : 5 16
new_class_scope      : 10 11
new_variables_scope  : 20 31 36 37
program              : 1 2
type                 : 18 19 20 30 41

Parsing method: LALR

state 0

    (0) S' -> . init
    (1) init -> . program
    (2) program -> . program class
    (3) program -> . class
    (4) class -> . field
    (5) class -> . method
    (6) class -> . CLASS error
    (7) class -> . expression
    (8) class -> . TYPE_IDENTIFIER
    (9) class -> . block
    (10) class -> . CLASS new_class_scope class-body
    (11) class -> . CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body
    (18) field -> . OBJECT_IDENTIFIER COLON type SEMICOLON
    (19) field -> . OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON
    (20) method -> . OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    CLASS           shift and go to state 6
    TYPE_IDENTIFIER shift and go to state 9
    OBJECT_IDENTIFIER shift and go to state 11
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    init                           shift and go to state 1
    program                        shift and go to state 2
    class                          shift and go to state 3
    field                          shift and go to state 4
    method                         shift and go to state 5
    expression                     shift and go to state 8
    block                          shift and go to state 10
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 1

    (0) S' -> init .



state 2

    (1) init -> program .
    (2) program -> program . class
    (4) class -> . field
    (5) class -> . method
    (6) class -> . CLASS error
    (7) class -> . expression
    (8) class -> . TYPE_IDENTIFIER
    (9) class -> . block
    (10) class -> . CLASS new_class_scope class-body
    (11) class -> . CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body
    (18) field -> . OBJECT_IDENTIFIER COLON type SEMICOLON
    (19) field -> . OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON
    (20) method -> . OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    $end            reduce using rule 1 (init -> program .)
    CLASS           shift and go to state 6
    TYPE_IDENTIFIER shift and go to state 9
    OBJECT_IDENTIFIER shift and go to state 11
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    class                          shift and go to state 31
    field                          shift and go to state 4
    method                         shift and go to state 5
    expression                     shift and go to state 8
    block                          shift and go to state 10
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 3

    (3) program -> class .

    CLASS           reduce using rule 3 (program -> class .)
    TYPE_IDENTIFIER reduce using rule 3 (program -> class .)
    OBJECT_IDENTIFIER reduce using rule 3 (program -> class .)
    WHILE           reduce using rule 3 (program -> class .)
    LET             reduce using rule 3 (program -> class .)
    NOT             reduce using rule 3 (program -> class .)
    MINUS           reduce using rule 3 (program -> class .)
    ISNULL          reduce using rule 3 (program -> class .)
    NEW             reduce using rule 3 (program -> class .)
    SELF            reduce using rule 3 (program -> class .)
    LPAR            reduce using rule 3 (program -> class .)
    error           reduce using rule 3 (program -> class .)
    IF              reduce using rule 3 (program -> class .)
    LBRACE          reduce using rule 3 (program -> class .)
    INTEGER_LITERAL reduce using rule 3 (program -> class .)
    string_literal  reduce using rule 3 (program -> class .)
    TRUE            reduce using rule 3 (program -> class .)
    FALSE           reduce using rule 3 (program -> class .)
    $end            reduce using rule 3 (program -> class .)


state 4

    (4) class -> field .

    CLASS           reduce using rule 4 (class -> field .)
    TYPE_IDENTIFIER reduce using rule 4 (class -> field .)
    OBJECT_IDENTIFIER reduce using rule 4 (class -> field .)
    WHILE           reduce using rule 4 (class -> field .)
    LET             reduce using rule 4 (class -> field .)
    NOT             reduce using rule 4 (class -> field .)
    MINUS           reduce using rule 4 (class -> field .)
    ISNULL          reduce using rule 4 (class -> field .)
    NEW             reduce using rule 4 (class -> field .)
    SELF            reduce using rule 4 (class -> field .)
    LPAR            reduce using rule 4 (class -> field .)
    error           reduce using rule 4 (class -> field .)
    IF              reduce using rule 4 (class -> field .)
    LBRACE          reduce using rule 4 (class -> field .)
    INTEGER_LITERAL reduce using rule 4 (class -> field .)
    string_literal  reduce using rule 4 (class -> field .)
    TRUE            reduce using rule 4 (class -> field .)
    FALSE           reduce using rule 4 (class -> field .)
    $end            reduce using rule 4 (class -> field .)


state 5

    (5) class -> method .

    CLASS           reduce using rule 5 (class -> method .)
    TYPE_IDENTIFIER reduce using rule 5 (class -> method .)
    OBJECT_IDENTIFIER reduce using rule 5 (class -> method .)
    WHILE           reduce using rule 5 (class -> method .)
    LET             reduce using rule 5 (class -> method .)
    NOT             reduce using rule 5 (class -> method .)
    MINUS           reduce using rule 5 (class -> method .)
    ISNULL          reduce using rule 5 (class -> method .)
    NEW             reduce using rule 5 (class -> method .)
    SELF            reduce using rule 5 (class -> method .)
    LPAR            reduce using rule 5 (class -> method .)
    error           reduce using rule 5 (class -> method .)
    IF              reduce using rule 5 (class -> method .)
    LBRACE          reduce using rule 5 (class -> method .)
    INTEGER_LITERAL reduce using rule 5 (class -> method .)
    string_literal  reduce using rule 5 (class -> method .)
    TRUE            reduce using rule 5 (class -> method .)
    FALSE           reduce using rule 5 (class -> method .)
    $end            reduce using rule 5 (class -> method .)


state 6

    (6) class -> CLASS . error
    (10) class -> CLASS . new_class_scope class-body
    (11) class -> CLASS . new_class_scope EXTENDS TYPE_IDENTIFIER class-body
    (12) new_class_scope -> . TYPE_IDENTIFIER

    error           shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 34

    new_class_scope                shift and go to state 33

state 7

    (65) expression -> error . expression RPAR
    (67) expression -> error .
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for OBJECT_IDENTIFIER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ISNULL resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for SELF resolved as shift
  ! shift/reduce conflict for LPAR resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for INTEGER_LITERAL resolved as shift
  ! shift/reduce conflict for string_literal resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    PLUS            reduce using rule 67 (expression -> error .)
    TIMES           reduce using rule 67 (expression -> error .)
    DIV             reduce using rule 67 (expression -> error .)
    EQUAL           reduce using rule 67 (expression -> error .)
    LOWER_EQUAL     reduce using rule 67 (expression -> error .)
    LOWER           reduce using rule 67 (expression -> error .)
    POW             reduce using rule 67 (expression -> error .)
    AND             reduce using rule 67 (expression -> error .)
    DOT             reduce using rule 67 (expression -> error .)
    CLASS           reduce using rule 67 (expression -> error .)
    TYPE_IDENTIFIER reduce using rule 67 (expression -> error .)
    $end            reduce using rule 67 (expression -> error .)
    RPAR            reduce using rule 67 (expression -> error .)
    THEN            reduce using rule 67 (expression -> error .)
    DO              reduce using rule 67 (expression -> error .)
    COMMA           reduce using rule 67 (expression -> error .)
    RBRACE          reduce using rule 67 (expression -> error .)
    SEMICOLON       reduce using rule 67 (expression -> error .)
    IN              reduce using rule 67 (expression -> error .)
    ELSE            reduce using rule 67 (expression -> error .)
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! MINUS           [ reduce using rule 67 (expression -> error .) ]
  ! OBJECT_IDENTIFIER [ reduce using rule 67 (expression -> error .) ]
  ! WHILE           [ reduce using rule 67 (expression -> error .) ]
  ! LET             [ reduce using rule 67 (expression -> error .) ]
  ! NOT             [ reduce using rule 67 (expression -> error .) ]
  ! ISNULL          [ reduce using rule 67 (expression -> error .) ]
  ! NEW             [ reduce using rule 67 (expression -> error .) ]
  ! SELF            [ reduce using rule 67 (expression -> error .) ]
  ! LPAR            [ reduce using rule 67 (expression -> error .) ]
  ! error           [ reduce using rule 67 (expression -> error .) ]
  ! IF              [ reduce using rule 67 (expression -> error .) ]
  ! LBRACE          [ reduce using rule 67 (expression -> error .) ]
  ! INTEGER_LITERAL [ reduce using rule 67 (expression -> error .) ]
  ! string_literal  [ reduce using rule 67 (expression -> error .) ]
  ! TRUE            [ reduce using rule 67 (expression -> error .) ]
  ! FALSE           [ reduce using rule 67 (expression -> error .) ]
  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 35
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 8

    (7) class -> expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

  ! shift/reduce conflict for MINUS resolved as shift
    CLASS           reduce using rule 7 (class -> expression .)
    TYPE_IDENTIFIER reduce using rule 7 (class -> expression .)
    OBJECT_IDENTIFIER reduce using rule 7 (class -> expression .)
    WHILE           reduce using rule 7 (class -> expression .)
    LET             reduce using rule 7 (class -> expression .)
    NOT             reduce using rule 7 (class -> expression .)
    ISNULL          reduce using rule 7 (class -> expression .)
    NEW             reduce using rule 7 (class -> expression .)
    SELF            reduce using rule 7 (class -> expression .)
    LPAR            reduce using rule 7 (class -> expression .)
    error           reduce using rule 7 (class -> expression .)
    IF              reduce using rule 7 (class -> expression .)
    LBRACE          reduce using rule 7 (class -> expression .)
    INTEGER_LITERAL reduce using rule 7 (class -> expression .)
    string_literal  reduce using rule 7 (class -> expression .)
    TRUE            reduce using rule 7 (class -> expression .)
    FALSE           reduce using rule 7 (class -> expression .)
    $end            reduce using rule 7 (class -> expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47

  ! MINUS           [ reduce using rule 7 (class -> expression .) ]


state 9

    (8) class -> TYPE_IDENTIFIER .

    CLASS           reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    OBJECT_IDENTIFIER reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    WHILE           reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    LET             reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    NOT             reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    MINUS           reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    ISNULL          reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    NEW             reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    SELF            reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    LPAR            reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    error           reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    IF              reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    LBRACE          reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    INTEGER_LITERAL reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    string_literal  reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    TRUE            reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    FALSE           reduce using rule 8 (class -> TYPE_IDENTIFIER .)
    $end            reduce using rule 8 (class -> TYPE_IDENTIFIER .)


state 10

    (9) class -> block .
    (66) expression -> block .

  ! reduce/reduce conflict for MINUS resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for CLASS resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for TYPE_IDENTIFIER resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for OBJECT_IDENTIFIER resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for WHILE resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for LET resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for NOT resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for ISNULL resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for NEW resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for SELF resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for LPAR resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for error resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for IF resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for LBRACE resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for INTEGER_LITERAL resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for string_literal resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for TRUE resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for FALSE resolved using rule 9 (class -> block .)
  ! reduce/reduce conflict for $end resolved using rule 9 (class -> block .)
    CLASS           reduce using rule 9 (class -> block .)
    TYPE_IDENTIFIER reduce using rule 9 (class -> block .)
    OBJECT_IDENTIFIER reduce using rule 9 (class -> block .)
    WHILE           reduce using rule 9 (class -> block .)
    LET             reduce using rule 9 (class -> block .)
    NOT             reduce using rule 9 (class -> block .)
    MINUS           reduce using rule 9 (class -> block .)
    ISNULL          reduce using rule 9 (class -> block .)
    NEW             reduce using rule 9 (class -> block .)
    SELF            reduce using rule 9 (class -> block .)
    LPAR            reduce using rule 9 (class -> block .)
    error           reduce using rule 9 (class -> block .)
    IF              reduce using rule 9 (class -> block .)
    LBRACE          reduce using rule 9 (class -> block .)
    INTEGER_LITERAL reduce using rule 9 (class -> block .)
    string_literal  reduce using rule 9 (class -> block .)
    TRUE            reduce using rule 9 (class -> block .)
    FALSE           reduce using rule 9 (class -> block .)
    $end            reduce using rule 9 (class -> block .)
    PLUS            reduce using rule 66 (expression -> block .)
    TIMES           reduce using rule 66 (expression -> block .)
    DIV             reduce using rule 66 (expression -> block .)
    EQUAL           reduce using rule 66 (expression -> block .)
    LOWER_EQUAL     reduce using rule 66 (expression -> block .)
    LOWER           reduce using rule 66 (expression -> block .)
    POW             reduce using rule 66 (expression -> block .)
    AND             reduce using rule 66 (expression -> block .)
    DOT             reduce using rule 66 (expression -> block .)

  ! MINUS           [ reduce using rule 66 (expression -> block .) ]
  ! CLASS           [ reduce using rule 66 (expression -> block .) ]
  ! TYPE_IDENTIFIER [ reduce using rule 66 (expression -> block .) ]
  ! OBJECT_IDENTIFIER [ reduce using rule 66 (expression -> block .) ]
  ! WHILE           [ reduce using rule 66 (expression -> block .) ]
  ! LET             [ reduce using rule 66 (expression -> block .) ]
  ! NOT             [ reduce using rule 66 (expression -> block .) ]
  ! ISNULL          [ reduce using rule 66 (expression -> block .) ]
  ! NEW             [ reduce using rule 66 (expression -> block .) ]
  ! SELF            [ reduce using rule 66 (expression -> block .) ]
  ! LPAR            [ reduce using rule 66 (expression -> block .) ]
  ! error           [ reduce using rule 66 (expression -> block .) ]
  ! IF              [ reduce using rule 66 (expression -> block .) ]
  ! LBRACE          [ reduce using rule 66 (expression -> block .) ]
  ! INTEGER_LITERAL [ reduce using rule 66 (expression -> block .) ]
  ! string_literal  [ reduce using rule 66 (expression -> block .) ]
  ! TRUE            [ reduce using rule 66 (expression -> block .) ]
  ! FALSE           [ reduce using rule 66 (expression -> block .) ]
  ! $end            [ reduce using rule 66 (expression -> block .) ]


state 11

    (18) field -> OBJECT_IDENTIFIER . COLON type SEMICOLON
    (19) field -> OBJECT_IDENTIFIER . COLON type ASSIGN expression SEMICOLON
    (20) method -> OBJECT_IDENTIFIER . new_variables_scope LPAR formals RPAR COLON type block
    (42) expression -> OBJECT_IDENTIFIER . ASSIGN get_type expression
    (56) expression -> OBJECT_IDENTIFIER . LPAR args RPAR
    (59) expression -> OBJECT_IDENTIFIER .
    (21) new_variables_scope -> .

  ! shift/reduce conflict for LPAR resolved as shift
  ! shift/reduce conflict for LPAR resolved as shift
    COLON           shift and go to state 48
    ASSIGN          shift and go to state 49
    LPAR            shift and go to state 51
    PLUS            reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    MINUS           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    TIMES           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    DIV             reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    EQUAL           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    LOWER_EQUAL     reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    LOWER           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    POW             reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    AND             reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    DOT             reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    CLASS           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    OBJECT_IDENTIFIER reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    WHILE           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    LET             reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    NOT             reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    ISNULL          reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    NEW             reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    SELF            reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    error           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    IF              reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    LBRACE          reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    INTEGER_LITERAL reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    string_literal  reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    TRUE            reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    FALSE           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    $end            reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)

  ! LPAR            [ reduce using rule 59 (expression -> OBJECT_IDENTIFIER .) ]
  ! LPAR            [ reduce using rule 21 (new_variables_scope -> .) ]

    new_variables_scope            shift and go to state 50

state 12

    (36) expression -> new_variables_scope . IF expression THEN expression
    (37) expression -> new_variables_scope . IF expression THEN expression ELSE expression

    IF              shift and go to state 52


state 13

    (62) expression -> LPAR . RPAR
    (63) expression -> LPAR . expression RPAR
    (64) expression -> LPAR . expression error
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    RPAR            shift and go to state 53
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 54
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 14

    (68) expression -> IF . expression THEN expression SEMICOLON error
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 55
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 15

    (38) expression -> WHILE . expression DO expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 56
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 16

    (39) expression -> LET . let_type IN expression
    (40) expression -> LET . let_type ASSIGN expression IN expression
    (41) let_type -> . OBJECT_IDENTIFIER COLON type

    OBJECT_IDENTIFIER shift and go to state 58

    let_type                       shift and go to state 57

state 17

    (44) expression -> NOT . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 59
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 18

    (45) expression -> MINUS . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 60
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 19

    (46) expression -> ISNULL . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 61
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 20

    (58) expression -> NEW . TYPE_IDENTIFIER

    TYPE_IDENTIFIER shift and go to state 62


state 21

    (60) expression -> SELF .

    PLUS            reduce using rule 60 (expression -> SELF .)
    MINUS           reduce using rule 60 (expression -> SELF .)
    TIMES           reduce using rule 60 (expression -> SELF .)
    DIV             reduce using rule 60 (expression -> SELF .)
    EQUAL           reduce using rule 60 (expression -> SELF .)
    LOWER_EQUAL     reduce using rule 60 (expression -> SELF .)
    LOWER           reduce using rule 60 (expression -> SELF .)
    POW             reduce using rule 60 (expression -> SELF .)
    AND             reduce using rule 60 (expression -> SELF .)
    DOT             reduce using rule 60 (expression -> SELF .)
    CLASS           reduce using rule 60 (expression -> SELF .)
    TYPE_IDENTIFIER reduce using rule 60 (expression -> SELF .)
    OBJECT_IDENTIFIER reduce using rule 60 (expression -> SELF .)
    WHILE           reduce using rule 60 (expression -> SELF .)
    LET             reduce using rule 60 (expression -> SELF .)
    NOT             reduce using rule 60 (expression -> SELF .)
    ISNULL          reduce using rule 60 (expression -> SELF .)
    NEW             reduce using rule 60 (expression -> SELF .)
    SELF            reduce using rule 60 (expression -> SELF .)
    LPAR            reduce using rule 60 (expression -> SELF .)
    error           reduce using rule 60 (expression -> SELF .)
    IF              reduce using rule 60 (expression -> SELF .)
    LBRACE          reduce using rule 60 (expression -> SELF .)
    INTEGER_LITERAL reduce using rule 60 (expression -> SELF .)
    string_literal  reduce using rule 60 (expression -> SELF .)
    TRUE            reduce using rule 60 (expression -> SELF .)
    FALSE           reduce using rule 60 (expression -> SELF .)
    $end            reduce using rule 60 (expression -> SELF .)
    RPAR            reduce using rule 60 (expression -> SELF .)
    THEN            reduce using rule 60 (expression -> SELF .)
    DO              reduce using rule 60 (expression -> SELF .)
    COMMA           reduce using rule 60 (expression -> SELF .)
    RBRACE          reduce using rule 60 (expression -> SELF .)
    SEMICOLON       reduce using rule 60 (expression -> SELF .)
    IN              reduce using rule 60 (expression -> SELF .)
    ELSE            reduce using rule 60 (expression -> SELF .)


state 22

    (61) expression -> literal .

    PLUS            reduce using rule 61 (expression -> literal .)
    MINUS           reduce using rule 61 (expression -> literal .)
    TIMES           reduce using rule 61 (expression -> literal .)
    DIV             reduce using rule 61 (expression -> literal .)
    EQUAL           reduce using rule 61 (expression -> literal .)
    LOWER_EQUAL     reduce using rule 61 (expression -> literal .)
    LOWER           reduce using rule 61 (expression -> literal .)
    POW             reduce using rule 61 (expression -> literal .)
    AND             reduce using rule 61 (expression -> literal .)
    DOT             reduce using rule 61 (expression -> literal .)
    CLASS           reduce using rule 61 (expression -> literal .)
    TYPE_IDENTIFIER reduce using rule 61 (expression -> literal .)
    OBJECT_IDENTIFIER reduce using rule 61 (expression -> literal .)
    WHILE           reduce using rule 61 (expression -> literal .)
    LET             reduce using rule 61 (expression -> literal .)
    NOT             reduce using rule 61 (expression -> literal .)
    ISNULL          reduce using rule 61 (expression -> literal .)
    NEW             reduce using rule 61 (expression -> literal .)
    SELF            reduce using rule 61 (expression -> literal .)
    LPAR            reduce using rule 61 (expression -> literal .)
    error           reduce using rule 61 (expression -> literal .)
    IF              reduce using rule 61 (expression -> literal .)
    LBRACE          reduce using rule 61 (expression -> literal .)
    INTEGER_LITERAL reduce using rule 61 (expression -> literal .)
    string_literal  reduce using rule 61 (expression -> literal .)
    TRUE            reduce using rule 61 (expression -> literal .)
    FALSE           reduce using rule 61 (expression -> literal .)
    $end            reduce using rule 61 (expression -> literal .)
    RPAR            reduce using rule 61 (expression -> literal .)
    THEN            reduce using rule 61 (expression -> literal .)
    DO              reduce using rule 61 (expression -> literal .)
    COMMA           reduce using rule 61 (expression -> literal .)
    RBRACE          reduce using rule 61 (expression -> literal .)
    SEMICOLON       reduce using rule 61 (expression -> literal .)
    IN              reduce using rule 61 (expression -> literal .)
    ELSE            reduce using rule 61 (expression -> literal .)


state 23

    (31) block -> LBRACE . new_variables_scope inblock RBRACE
    (21) new_variables_scope -> .

    WHILE           reduce using rule 21 (new_variables_scope -> .)
    LET             reduce using rule 21 (new_variables_scope -> .)
    OBJECT_IDENTIFIER reduce using rule 21 (new_variables_scope -> .)
    NOT             reduce using rule 21 (new_variables_scope -> .)
    MINUS           reduce using rule 21 (new_variables_scope -> .)
    ISNULL          reduce using rule 21 (new_variables_scope -> .)
    NEW             reduce using rule 21 (new_variables_scope -> .)
    SELF            reduce using rule 21 (new_variables_scope -> .)
    LPAR            reduce using rule 21 (new_variables_scope -> .)
    error           reduce using rule 21 (new_variables_scope -> .)
    IF              reduce using rule 21 (new_variables_scope -> .)
    LBRACE          reduce using rule 21 (new_variables_scope -> .)
    INTEGER_LITERAL reduce using rule 21 (new_variables_scope -> .)
    string_literal  reduce using rule 21 (new_variables_scope -> .)
    TRUE            reduce using rule 21 (new_variables_scope -> .)
    FALSE           reduce using rule 21 (new_variables_scope -> .)
    RBRACE          reduce using rule 21 (new_variables_scope -> .)
    SEMICOLON       reduce using rule 21 (new_variables_scope -> .)

    new_variables_scope            shift and go to state 63

state 24

    (72) literal -> literal_integer .

    PLUS            reduce using rule 72 (literal -> literal_integer .)
    MINUS           reduce using rule 72 (literal -> literal_integer .)
    TIMES           reduce using rule 72 (literal -> literal_integer .)
    DIV             reduce using rule 72 (literal -> literal_integer .)
    EQUAL           reduce using rule 72 (literal -> literal_integer .)
    LOWER_EQUAL     reduce using rule 72 (literal -> literal_integer .)
    LOWER           reduce using rule 72 (literal -> literal_integer .)
    POW             reduce using rule 72 (literal -> literal_integer .)
    AND             reduce using rule 72 (literal -> literal_integer .)
    DOT             reduce using rule 72 (literal -> literal_integer .)
    CLASS           reduce using rule 72 (literal -> literal_integer .)
    TYPE_IDENTIFIER reduce using rule 72 (literal -> literal_integer .)
    OBJECT_IDENTIFIER reduce using rule 72 (literal -> literal_integer .)
    WHILE           reduce using rule 72 (literal -> literal_integer .)
    LET             reduce using rule 72 (literal -> literal_integer .)
    NOT             reduce using rule 72 (literal -> literal_integer .)
    ISNULL          reduce using rule 72 (literal -> literal_integer .)
    NEW             reduce using rule 72 (literal -> literal_integer .)
    SELF            reduce using rule 72 (literal -> literal_integer .)
    LPAR            reduce using rule 72 (literal -> literal_integer .)
    error           reduce using rule 72 (literal -> literal_integer .)
    IF              reduce using rule 72 (literal -> literal_integer .)
    LBRACE          reduce using rule 72 (literal -> literal_integer .)
    INTEGER_LITERAL reduce using rule 72 (literal -> literal_integer .)
    string_literal  reduce using rule 72 (literal -> literal_integer .)
    TRUE            reduce using rule 72 (literal -> literal_integer .)
    FALSE           reduce using rule 72 (literal -> literal_integer .)
    $end            reduce using rule 72 (literal -> literal_integer .)
    RPAR            reduce using rule 72 (literal -> literal_integer .)
    THEN            reduce using rule 72 (literal -> literal_integer .)
    DO              reduce using rule 72 (literal -> literal_integer .)
    COMMA           reduce using rule 72 (literal -> literal_integer .)
    RBRACE          reduce using rule 72 (literal -> literal_integer .)
    SEMICOLON       reduce using rule 72 (literal -> literal_integer .)
    IN              reduce using rule 72 (literal -> literal_integer .)
    ELSE            reduce using rule 72 (literal -> literal_integer .)


state 25

    (73) literal -> literal_string .

    PLUS            reduce using rule 73 (literal -> literal_string .)
    MINUS           reduce using rule 73 (literal -> literal_string .)
    TIMES           reduce using rule 73 (literal -> literal_string .)
    DIV             reduce using rule 73 (literal -> literal_string .)
    EQUAL           reduce using rule 73 (literal -> literal_string .)
    LOWER_EQUAL     reduce using rule 73 (literal -> literal_string .)
    LOWER           reduce using rule 73 (literal -> literal_string .)
    POW             reduce using rule 73 (literal -> literal_string .)
    AND             reduce using rule 73 (literal -> literal_string .)
    DOT             reduce using rule 73 (literal -> literal_string .)
    CLASS           reduce using rule 73 (literal -> literal_string .)
    TYPE_IDENTIFIER reduce using rule 73 (literal -> literal_string .)
    OBJECT_IDENTIFIER reduce using rule 73 (literal -> literal_string .)
    WHILE           reduce using rule 73 (literal -> literal_string .)
    LET             reduce using rule 73 (literal -> literal_string .)
    NOT             reduce using rule 73 (literal -> literal_string .)
    ISNULL          reduce using rule 73 (literal -> literal_string .)
    NEW             reduce using rule 73 (literal -> literal_string .)
    SELF            reduce using rule 73 (literal -> literal_string .)
    LPAR            reduce using rule 73 (literal -> literal_string .)
    error           reduce using rule 73 (literal -> literal_string .)
    IF              reduce using rule 73 (literal -> literal_string .)
    LBRACE          reduce using rule 73 (literal -> literal_string .)
    INTEGER_LITERAL reduce using rule 73 (literal -> literal_string .)
    string_literal  reduce using rule 73 (literal -> literal_string .)
    TRUE            reduce using rule 73 (literal -> literal_string .)
    FALSE           reduce using rule 73 (literal -> literal_string .)
    $end            reduce using rule 73 (literal -> literal_string .)
    RPAR            reduce using rule 73 (literal -> literal_string .)
    THEN            reduce using rule 73 (literal -> literal_string .)
    DO              reduce using rule 73 (literal -> literal_string .)
    COMMA           reduce using rule 73 (literal -> literal_string .)
    RBRACE          reduce using rule 73 (literal -> literal_string .)
    SEMICOLON       reduce using rule 73 (literal -> literal_string .)
    IN              reduce using rule 73 (literal -> literal_string .)
    ELSE            reduce using rule 73 (literal -> literal_string .)


state 26

    (74) literal -> boolean-literal .

    PLUS            reduce using rule 74 (literal -> boolean-literal .)
    MINUS           reduce using rule 74 (literal -> boolean-literal .)
    TIMES           reduce using rule 74 (literal -> boolean-literal .)
    DIV             reduce using rule 74 (literal -> boolean-literal .)
    EQUAL           reduce using rule 74 (literal -> boolean-literal .)
    LOWER_EQUAL     reduce using rule 74 (literal -> boolean-literal .)
    LOWER           reduce using rule 74 (literal -> boolean-literal .)
    POW             reduce using rule 74 (literal -> boolean-literal .)
    AND             reduce using rule 74 (literal -> boolean-literal .)
    DOT             reduce using rule 74 (literal -> boolean-literal .)
    CLASS           reduce using rule 74 (literal -> boolean-literal .)
    TYPE_IDENTIFIER reduce using rule 74 (literal -> boolean-literal .)
    OBJECT_IDENTIFIER reduce using rule 74 (literal -> boolean-literal .)
    WHILE           reduce using rule 74 (literal -> boolean-literal .)
    LET             reduce using rule 74 (literal -> boolean-literal .)
    NOT             reduce using rule 74 (literal -> boolean-literal .)
    ISNULL          reduce using rule 74 (literal -> boolean-literal .)
    NEW             reduce using rule 74 (literal -> boolean-literal .)
    SELF            reduce using rule 74 (literal -> boolean-literal .)
    LPAR            reduce using rule 74 (literal -> boolean-literal .)
    error           reduce using rule 74 (literal -> boolean-literal .)
    IF              reduce using rule 74 (literal -> boolean-literal .)
    LBRACE          reduce using rule 74 (literal -> boolean-literal .)
    INTEGER_LITERAL reduce using rule 74 (literal -> boolean-literal .)
    string_literal  reduce using rule 74 (literal -> boolean-literal .)
    TRUE            reduce using rule 74 (literal -> boolean-literal .)
    FALSE           reduce using rule 74 (literal -> boolean-literal .)
    $end            reduce using rule 74 (literal -> boolean-literal .)
    RPAR            reduce using rule 74 (literal -> boolean-literal .)
    THEN            reduce using rule 74 (literal -> boolean-literal .)
    DO              reduce using rule 74 (literal -> boolean-literal .)
    COMMA           reduce using rule 74 (literal -> boolean-literal .)
    RBRACE          reduce using rule 74 (literal -> boolean-literal .)
    SEMICOLON       reduce using rule 74 (literal -> boolean-literal .)
    IN              reduce using rule 74 (literal -> boolean-literal .)
    ELSE            reduce using rule 74 (literal -> boolean-literal .)


state 27

    (76) literal_integer -> INTEGER_LITERAL .

    PLUS            reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    MINUS           reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    TIMES           reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    DIV             reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    EQUAL           reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    LOWER_EQUAL     reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    LOWER           reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    POW             reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    AND             reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    DOT             reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    CLASS           reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    TYPE_IDENTIFIER reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    OBJECT_IDENTIFIER reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    WHILE           reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    LET             reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    NOT             reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    ISNULL          reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    NEW             reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    SELF            reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    LPAR            reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    error           reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    IF              reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    LBRACE          reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    INTEGER_LITERAL reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    string_literal  reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    TRUE            reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    FALSE           reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    $end            reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    RPAR            reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    THEN            reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    DO              reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    COMMA           reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    RBRACE          reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    SEMICOLON       reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    IN              reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)
    ELSE            reduce using rule 76 (literal_integer -> INTEGER_LITERAL .)


state 28

    (75) literal_string -> string_literal .

    PLUS            reduce using rule 75 (literal_string -> string_literal .)
    MINUS           reduce using rule 75 (literal_string -> string_literal .)
    TIMES           reduce using rule 75 (literal_string -> string_literal .)
    DIV             reduce using rule 75 (literal_string -> string_literal .)
    EQUAL           reduce using rule 75 (literal_string -> string_literal .)
    LOWER_EQUAL     reduce using rule 75 (literal_string -> string_literal .)
    LOWER           reduce using rule 75 (literal_string -> string_literal .)
    POW             reduce using rule 75 (literal_string -> string_literal .)
    AND             reduce using rule 75 (literal_string -> string_literal .)
    DOT             reduce using rule 75 (literal_string -> string_literal .)
    CLASS           reduce using rule 75 (literal_string -> string_literal .)
    TYPE_IDENTIFIER reduce using rule 75 (literal_string -> string_literal .)
    OBJECT_IDENTIFIER reduce using rule 75 (literal_string -> string_literal .)
    WHILE           reduce using rule 75 (literal_string -> string_literal .)
    LET             reduce using rule 75 (literal_string -> string_literal .)
    NOT             reduce using rule 75 (literal_string -> string_literal .)
    ISNULL          reduce using rule 75 (literal_string -> string_literal .)
    NEW             reduce using rule 75 (literal_string -> string_literal .)
    SELF            reduce using rule 75 (literal_string -> string_literal .)
    LPAR            reduce using rule 75 (literal_string -> string_literal .)
    error           reduce using rule 75 (literal_string -> string_literal .)
    IF              reduce using rule 75 (literal_string -> string_literal .)
    LBRACE          reduce using rule 75 (literal_string -> string_literal .)
    INTEGER_LITERAL reduce using rule 75 (literal_string -> string_literal .)
    string_literal  reduce using rule 75 (literal_string -> string_literal .)
    TRUE            reduce using rule 75 (literal_string -> string_literal .)
    FALSE           reduce using rule 75 (literal_string -> string_literal .)
    $end            reduce using rule 75 (literal_string -> string_literal .)
    RPAR            reduce using rule 75 (literal_string -> string_literal .)
    THEN            reduce using rule 75 (literal_string -> string_literal .)
    DO              reduce using rule 75 (literal_string -> string_literal .)
    COMMA           reduce using rule 75 (literal_string -> string_literal .)
    RBRACE          reduce using rule 75 (literal_string -> string_literal .)
    SEMICOLON       reduce using rule 75 (literal_string -> string_literal .)
    IN              reduce using rule 75 (literal_string -> string_literal .)
    ELSE            reduce using rule 75 (literal_string -> string_literal .)


state 29

    (77) boolean-literal -> TRUE .

    PLUS            reduce using rule 77 (boolean-literal -> TRUE .)
    MINUS           reduce using rule 77 (boolean-literal -> TRUE .)
    TIMES           reduce using rule 77 (boolean-literal -> TRUE .)
    DIV             reduce using rule 77 (boolean-literal -> TRUE .)
    EQUAL           reduce using rule 77 (boolean-literal -> TRUE .)
    LOWER_EQUAL     reduce using rule 77 (boolean-literal -> TRUE .)
    LOWER           reduce using rule 77 (boolean-literal -> TRUE .)
    POW             reduce using rule 77 (boolean-literal -> TRUE .)
    AND             reduce using rule 77 (boolean-literal -> TRUE .)
    DOT             reduce using rule 77 (boolean-literal -> TRUE .)
    CLASS           reduce using rule 77 (boolean-literal -> TRUE .)
    TYPE_IDENTIFIER reduce using rule 77 (boolean-literal -> TRUE .)
    OBJECT_IDENTIFIER reduce using rule 77 (boolean-literal -> TRUE .)
    WHILE           reduce using rule 77 (boolean-literal -> TRUE .)
    LET             reduce using rule 77 (boolean-literal -> TRUE .)
    NOT             reduce using rule 77 (boolean-literal -> TRUE .)
    ISNULL          reduce using rule 77 (boolean-literal -> TRUE .)
    NEW             reduce using rule 77 (boolean-literal -> TRUE .)
    SELF            reduce using rule 77 (boolean-literal -> TRUE .)
    LPAR            reduce using rule 77 (boolean-literal -> TRUE .)
    error           reduce using rule 77 (boolean-literal -> TRUE .)
    IF              reduce using rule 77 (boolean-literal -> TRUE .)
    LBRACE          reduce using rule 77 (boolean-literal -> TRUE .)
    INTEGER_LITERAL reduce using rule 77 (boolean-literal -> TRUE .)
    string_literal  reduce using rule 77 (boolean-literal -> TRUE .)
    TRUE            reduce using rule 77 (boolean-literal -> TRUE .)
    FALSE           reduce using rule 77 (boolean-literal -> TRUE .)
    $end            reduce using rule 77 (boolean-literal -> TRUE .)
    RPAR            reduce using rule 77 (boolean-literal -> TRUE .)
    THEN            reduce using rule 77 (boolean-literal -> TRUE .)
    DO              reduce using rule 77 (boolean-literal -> TRUE .)
    COMMA           reduce using rule 77 (boolean-literal -> TRUE .)
    RBRACE          reduce using rule 77 (boolean-literal -> TRUE .)
    SEMICOLON       reduce using rule 77 (boolean-literal -> TRUE .)
    IN              reduce using rule 77 (boolean-literal -> TRUE .)
    ELSE            reduce using rule 77 (boolean-literal -> TRUE .)


state 30

    (78) boolean-literal -> FALSE .

    PLUS            reduce using rule 78 (boolean-literal -> FALSE .)
    MINUS           reduce using rule 78 (boolean-literal -> FALSE .)
    TIMES           reduce using rule 78 (boolean-literal -> FALSE .)
    DIV             reduce using rule 78 (boolean-literal -> FALSE .)
    EQUAL           reduce using rule 78 (boolean-literal -> FALSE .)
    LOWER_EQUAL     reduce using rule 78 (boolean-literal -> FALSE .)
    LOWER           reduce using rule 78 (boolean-literal -> FALSE .)
    POW             reduce using rule 78 (boolean-literal -> FALSE .)
    AND             reduce using rule 78 (boolean-literal -> FALSE .)
    DOT             reduce using rule 78 (boolean-literal -> FALSE .)
    CLASS           reduce using rule 78 (boolean-literal -> FALSE .)
    TYPE_IDENTIFIER reduce using rule 78 (boolean-literal -> FALSE .)
    OBJECT_IDENTIFIER reduce using rule 78 (boolean-literal -> FALSE .)
    WHILE           reduce using rule 78 (boolean-literal -> FALSE .)
    LET             reduce using rule 78 (boolean-literal -> FALSE .)
    NOT             reduce using rule 78 (boolean-literal -> FALSE .)
    ISNULL          reduce using rule 78 (boolean-literal -> FALSE .)
    NEW             reduce using rule 78 (boolean-literal -> FALSE .)
    SELF            reduce using rule 78 (boolean-literal -> FALSE .)
    LPAR            reduce using rule 78 (boolean-literal -> FALSE .)
    error           reduce using rule 78 (boolean-literal -> FALSE .)
    IF              reduce using rule 78 (boolean-literal -> FALSE .)
    LBRACE          reduce using rule 78 (boolean-literal -> FALSE .)
    INTEGER_LITERAL reduce using rule 78 (boolean-literal -> FALSE .)
    string_literal  reduce using rule 78 (boolean-literal -> FALSE .)
    TRUE            reduce using rule 78 (boolean-literal -> FALSE .)
    FALSE           reduce using rule 78 (boolean-literal -> FALSE .)
    $end            reduce using rule 78 (boolean-literal -> FALSE .)
    RPAR            reduce using rule 78 (boolean-literal -> FALSE .)
    THEN            reduce using rule 78 (boolean-literal -> FALSE .)
    DO              reduce using rule 78 (boolean-literal -> FALSE .)
    COMMA           reduce using rule 78 (boolean-literal -> FALSE .)
    RBRACE          reduce using rule 78 (boolean-literal -> FALSE .)
    SEMICOLON       reduce using rule 78 (boolean-literal -> FALSE .)
    IN              reduce using rule 78 (boolean-literal -> FALSE .)
    ELSE            reduce using rule 78 (boolean-literal -> FALSE .)


state 31

    (2) program -> program class .

    CLASS           reduce using rule 2 (program -> program class .)
    TYPE_IDENTIFIER reduce using rule 2 (program -> program class .)
    OBJECT_IDENTIFIER reduce using rule 2 (program -> program class .)
    WHILE           reduce using rule 2 (program -> program class .)
    LET             reduce using rule 2 (program -> program class .)
    NOT             reduce using rule 2 (program -> program class .)
    MINUS           reduce using rule 2 (program -> program class .)
    ISNULL          reduce using rule 2 (program -> program class .)
    NEW             reduce using rule 2 (program -> program class .)
    SELF            reduce using rule 2 (program -> program class .)
    LPAR            reduce using rule 2 (program -> program class .)
    error           reduce using rule 2 (program -> program class .)
    IF              reduce using rule 2 (program -> program class .)
    LBRACE          reduce using rule 2 (program -> program class .)
    INTEGER_LITERAL reduce using rule 2 (program -> program class .)
    string_literal  reduce using rule 2 (program -> program class .)
    TRUE            reduce using rule 2 (program -> program class .)
    FALSE           reduce using rule 2 (program -> program class .)
    $end            reduce using rule 2 (program -> program class .)


state 32

    (6) class -> CLASS error .

    CLASS           reduce using rule 6 (class -> CLASS error .)
    TYPE_IDENTIFIER reduce using rule 6 (class -> CLASS error .)
    OBJECT_IDENTIFIER reduce using rule 6 (class -> CLASS error .)
    WHILE           reduce using rule 6 (class -> CLASS error .)
    LET             reduce using rule 6 (class -> CLASS error .)
    NOT             reduce using rule 6 (class -> CLASS error .)
    MINUS           reduce using rule 6 (class -> CLASS error .)
    ISNULL          reduce using rule 6 (class -> CLASS error .)
    NEW             reduce using rule 6 (class -> CLASS error .)
    SELF            reduce using rule 6 (class -> CLASS error .)
    LPAR            reduce using rule 6 (class -> CLASS error .)
    error           reduce using rule 6 (class -> CLASS error .)
    IF              reduce using rule 6 (class -> CLASS error .)
    LBRACE          reduce using rule 6 (class -> CLASS error .)
    INTEGER_LITERAL reduce using rule 6 (class -> CLASS error .)
    string_literal  reduce using rule 6 (class -> CLASS error .)
    TRUE            reduce using rule 6 (class -> CLASS error .)
    FALSE           reduce using rule 6 (class -> CLASS error .)
    $end            reduce using rule 6 (class -> CLASS error .)


state 33

    (10) class -> CLASS new_class_scope . class-body
    (11) class -> CLASS new_class_scope . EXTENDS TYPE_IDENTIFIER class-body
    (13) class-body -> . LBRACE class-body-in RBRACE
    (14) class-body -> . LBRACE class-body-in error

    EXTENDS         shift and go to state 65
    LBRACE          shift and go to state 66

    class-body                     shift and go to state 64

state 34

    (12) new_class_scope -> TYPE_IDENTIFIER .

    EXTENDS         reduce using rule 12 (new_class_scope -> TYPE_IDENTIFIER .)
    LBRACE          reduce using rule 12 (new_class_scope -> TYPE_IDENTIFIER .)


state 35

    (65) expression -> error expression . RPAR
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    RPAR            shift and go to state 67
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47


state 36

    (42) expression -> OBJECT_IDENTIFIER . ASSIGN get_type expression
    (56) expression -> OBJECT_IDENTIFIER . LPAR args RPAR
    (59) expression -> OBJECT_IDENTIFIER .

  ! shift/reduce conflict for LPAR resolved as shift
    ASSIGN          shift and go to state 49
    LPAR            shift and go to state 51
    RPAR            reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    PLUS            reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    MINUS           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    TIMES           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    DIV             reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    EQUAL           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    LOWER_EQUAL     reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    LOWER           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    POW             reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    AND             reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    DOT             reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    error           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    THEN            reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    DO              reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    CLASS           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    OBJECT_IDENTIFIER reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    WHILE           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    LET             reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    NOT             reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    ISNULL          reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    NEW             reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    SELF            reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    IF              reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    LBRACE          reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    INTEGER_LITERAL reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    string_literal  reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    TRUE            reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    FALSE           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    $end            reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    COMMA           reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    RBRACE          reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    SEMICOLON       reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    IN              reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)
    ELSE            reduce using rule 59 (expression -> OBJECT_IDENTIFIER .)

  ! LPAR            [ reduce using rule 59 (expression -> OBJECT_IDENTIFIER .) ]


state 37

    (66) expression -> block .

    RPAR            reduce using rule 66 (expression -> block .)
    PLUS            reduce using rule 66 (expression -> block .)
    MINUS           reduce using rule 66 (expression -> block .)
    TIMES           reduce using rule 66 (expression -> block .)
    DIV             reduce using rule 66 (expression -> block .)
    EQUAL           reduce using rule 66 (expression -> block .)
    LOWER_EQUAL     reduce using rule 66 (expression -> block .)
    LOWER           reduce using rule 66 (expression -> block .)
    POW             reduce using rule 66 (expression -> block .)
    AND             reduce using rule 66 (expression -> block .)
    DOT             reduce using rule 66 (expression -> block .)
    error           reduce using rule 66 (expression -> block .)
    THEN            reduce using rule 66 (expression -> block .)
    DO              reduce using rule 66 (expression -> block .)
    CLASS           reduce using rule 66 (expression -> block .)
    TYPE_IDENTIFIER reduce using rule 66 (expression -> block .)
    OBJECT_IDENTIFIER reduce using rule 66 (expression -> block .)
    WHILE           reduce using rule 66 (expression -> block .)
    LET             reduce using rule 66 (expression -> block .)
    NOT             reduce using rule 66 (expression -> block .)
    ISNULL          reduce using rule 66 (expression -> block .)
    NEW             reduce using rule 66 (expression -> block .)
    SELF            reduce using rule 66 (expression -> block .)
    LPAR            reduce using rule 66 (expression -> block .)
    IF              reduce using rule 66 (expression -> block .)
    LBRACE          reduce using rule 66 (expression -> block .)
    INTEGER_LITERAL reduce using rule 66 (expression -> block .)
    string_literal  reduce using rule 66 (expression -> block .)
    TRUE            reduce using rule 66 (expression -> block .)
    FALSE           reduce using rule 66 (expression -> block .)
    $end            reduce using rule 66 (expression -> block .)
    COMMA           reduce using rule 66 (expression -> block .)
    RBRACE          reduce using rule 66 (expression -> block .)
    SEMICOLON       reduce using rule 66 (expression -> block .)
    IN              reduce using rule 66 (expression -> block .)
    ELSE            reduce using rule 66 (expression -> block .)


state 38

    (47) expression -> expression PLUS . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 68
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 39

    (48) expression -> expression MINUS . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 69
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 40

    (49) expression -> expression TIMES . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 70
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 41

    (50) expression -> expression DIV . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 71
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 42

    (51) expression -> expression EQUAL . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 72
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 43

    (52) expression -> expression LOWER_EQUAL . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 73
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 44

    (53) expression -> expression LOWER . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 74
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 45

    (54) expression -> expression POW . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 75
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 46

    (55) expression -> expression AND . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 76
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 47

    (57) expression -> expression DOT . OBJECT_IDENTIFIER LPAR args RPAR

    OBJECT_IDENTIFIER shift and go to state 77


state 48

    (18) field -> OBJECT_IDENTIFIER COLON . type SEMICOLON
    (19) field -> OBJECT_IDENTIFIER COLON . type ASSIGN expression SEMICOLON
    (22) type -> . TYPE_IDENTIFIER
    (23) type -> . INT32
    (24) type -> . BOOL
    (25) type -> . STRING
    (26) type -> . UNIT

    TYPE_IDENTIFIER shift and go to state 79
    INT32           shift and go to state 80
    BOOL            shift and go to state 81
    STRING          shift and go to state 82
    UNIT            shift and go to state 83

    type                           shift and go to state 78

state 49

    (42) expression -> OBJECT_IDENTIFIER ASSIGN . get_type expression
    (43) get_type -> .

    WHILE           reduce using rule 43 (get_type -> .)
    LET             reduce using rule 43 (get_type -> .)
    OBJECT_IDENTIFIER reduce using rule 43 (get_type -> .)
    NOT             reduce using rule 43 (get_type -> .)
    MINUS           reduce using rule 43 (get_type -> .)
    ISNULL          reduce using rule 43 (get_type -> .)
    NEW             reduce using rule 43 (get_type -> .)
    SELF            reduce using rule 43 (get_type -> .)
    LPAR            reduce using rule 43 (get_type -> .)
    error           reduce using rule 43 (get_type -> .)
    IF              reduce using rule 43 (get_type -> .)
    LBRACE          reduce using rule 43 (get_type -> .)
    INTEGER_LITERAL reduce using rule 43 (get_type -> .)
    string_literal  reduce using rule 43 (get_type -> .)
    TRUE            reduce using rule 43 (get_type -> .)
    FALSE           reduce using rule 43 (get_type -> .)

    get_type                       shift and go to state 84

state 50

    (20) method -> OBJECT_IDENTIFIER new_variables_scope . LPAR formals RPAR COLON type block

    LPAR            shift and go to state 85


state 51

    (56) expression -> OBJECT_IDENTIFIER LPAR . args RPAR
    (69) args -> . args COMMA expression
    (70) args -> . expression
    (71) args -> .
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    RPAR            reduce using rule 71 (args -> .)
    COMMA           reduce using rule 71 (args -> .)
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    args                           shift and go to state 86
    expression                     shift and go to state 87
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 52

    (36) expression -> new_variables_scope IF . expression THEN expression
    (37) expression -> new_variables_scope IF . expression THEN expression ELSE expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    new_variables_scope            shift and go to state 12
    expression                     shift and go to state 88
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 53

    (62) expression -> LPAR RPAR .

    PLUS            reduce using rule 62 (expression -> LPAR RPAR .)
    MINUS           reduce using rule 62 (expression -> LPAR RPAR .)
    TIMES           reduce using rule 62 (expression -> LPAR RPAR .)
    DIV             reduce using rule 62 (expression -> LPAR RPAR .)
    EQUAL           reduce using rule 62 (expression -> LPAR RPAR .)
    LOWER_EQUAL     reduce using rule 62 (expression -> LPAR RPAR .)
    LOWER           reduce using rule 62 (expression -> LPAR RPAR .)
    POW             reduce using rule 62 (expression -> LPAR RPAR .)
    AND             reduce using rule 62 (expression -> LPAR RPAR .)
    DOT             reduce using rule 62 (expression -> LPAR RPAR .)
    CLASS           reduce using rule 62 (expression -> LPAR RPAR .)
    TYPE_IDENTIFIER reduce using rule 62 (expression -> LPAR RPAR .)
    OBJECT_IDENTIFIER reduce using rule 62 (expression -> LPAR RPAR .)
    WHILE           reduce using rule 62 (expression -> LPAR RPAR .)
    LET             reduce using rule 62 (expression -> LPAR RPAR .)
    NOT             reduce using rule 62 (expression -> LPAR RPAR .)
    ISNULL          reduce using rule 62 (expression -> LPAR RPAR .)
    NEW             reduce using rule 62 (expression -> LPAR RPAR .)
    SELF            reduce using rule 62 (expression -> LPAR RPAR .)
    LPAR            reduce using rule 62 (expression -> LPAR RPAR .)
    error           reduce using rule 62 (expression -> LPAR RPAR .)
    IF              reduce using rule 62 (expression -> LPAR RPAR .)
    LBRACE          reduce using rule 62 (expression -> LPAR RPAR .)
    INTEGER_LITERAL reduce using rule 62 (expression -> LPAR RPAR .)
    string_literal  reduce using rule 62 (expression -> LPAR RPAR .)
    TRUE            reduce using rule 62 (expression -> LPAR RPAR .)
    FALSE           reduce using rule 62 (expression -> LPAR RPAR .)
    $end            reduce using rule 62 (expression -> LPAR RPAR .)
    RPAR            reduce using rule 62 (expression -> LPAR RPAR .)
    THEN            reduce using rule 62 (expression -> LPAR RPAR .)
    DO              reduce using rule 62 (expression -> LPAR RPAR .)
    COMMA           reduce using rule 62 (expression -> LPAR RPAR .)
    RBRACE          reduce using rule 62 (expression -> LPAR RPAR .)
    SEMICOLON       reduce using rule 62 (expression -> LPAR RPAR .)
    IN              reduce using rule 62 (expression -> LPAR RPAR .)
    ELSE            reduce using rule 62 (expression -> LPAR RPAR .)


state 54

    (63) expression -> LPAR expression . RPAR
    (64) expression -> LPAR expression . error
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    RPAR            shift and go to state 89
    error           shift and go to state 90
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47


state 55

    (68) expression -> IF expression . THEN expression SEMICOLON error
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    THEN            shift and go to state 91
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47


state 56

    (38) expression -> WHILE expression . DO expression
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    DO              shift and go to state 92
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47


state 57

    (39) expression -> LET let_type . IN expression
    (40) expression -> LET let_type . ASSIGN expression IN expression

    IN              shift and go to state 93
    ASSIGN          shift and go to state 94


state 58

    (41) let_type -> OBJECT_IDENTIFIER . COLON type

    COLON           shift and go to state 95


state 59

    (44) expression -> NOT expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    AND             reduce using rule 44 (expression -> NOT expression .)
    CLASS           reduce using rule 44 (expression -> NOT expression .)
    TYPE_IDENTIFIER reduce using rule 44 (expression -> NOT expression .)
    OBJECT_IDENTIFIER reduce using rule 44 (expression -> NOT expression .)
    WHILE           reduce using rule 44 (expression -> NOT expression .)
    LET             reduce using rule 44 (expression -> NOT expression .)
    NOT             reduce using rule 44 (expression -> NOT expression .)
    ISNULL          reduce using rule 44 (expression -> NOT expression .)
    NEW             reduce using rule 44 (expression -> NOT expression .)
    SELF            reduce using rule 44 (expression -> NOT expression .)
    LPAR            reduce using rule 44 (expression -> NOT expression .)
    error           reduce using rule 44 (expression -> NOT expression .)
    IF              reduce using rule 44 (expression -> NOT expression .)
    LBRACE          reduce using rule 44 (expression -> NOT expression .)
    INTEGER_LITERAL reduce using rule 44 (expression -> NOT expression .)
    string_literal  reduce using rule 44 (expression -> NOT expression .)
    TRUE            reduce using rule 44 (expression -> NOT expression .)
    FALSE           reduce using rule 44 (expression -> NOT expression .)
    $end            reduce using rule 44 (expression -> NOT expression .)
    RPAR            reduce using rule 44 (expression -> NOT expression .)
    THEN            reduce using rule 44 (expression -> NOT expression .)
    DO              reduce using rule 44 (expression -> NOT expression .)
    COMMA           reduce using rule 44 (expression -> NOT expression .)
    RBRACE          reduce using rule 44 (expression -> NOT expression .)
    SEMICOLON       reduce using rule 44 (expression -> NOT expression .)
    IN              reduce using rule 44 (expression -> NOT expression .)
    ELSE            reduce using rule 44 (expression -> NOT expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    DOT             shift and go to state 47

  ! PLUS            [ reduce using rule 44 (expression -> NOT expression .) ]
  ! MINUS           [ reduce using rule 44 (expression -> NOT expression .) ]
  ! TIMES           [ reduce using rule 44 (expression -> NOT expression .) ]
  ! DIV             [ reduce using rule 44 (expression -> NOT expression .) ]
  ! EQUAL           [ reduce using rule 44 (expression -> NOT expression .) ]
  ! LOWER_EQUAL     [ reduce using rule 44 (expression -> NOT expression .) ]
  ! LOWER           [ reduce using rule 44 (expression -> NOT expression .) ]
  ! POW             [ reduce using rule 44 (expression -> NOT expression .) ]
  ! DOT             [ reduce using rule 44 (expression -> NOT expression .) ]
  ! AND             [ shift and go to state 46 ]


state 60

    (45) expression -> MINUS expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    PLUS            reduce using rule 45 (expression -> MINUS expression .)
    MINUS           reduce using rule 45 (expression -> MINUS expression .)
    TIMES           reduce using rule 45 (expression -> MINUS expression .)
    DIV             reduce using rule 45 (expression -> MINUS expression .)
    EQUAL           reduce using rule 45 (expression -> MINUS expression .)
    LOWER_EQUAL     reduce using rule 45 (expression -> MINUS expression .)
    LOWER           reduce using rule 45 (expression -> MINUS expression .)
    AND             reduce using rule 45 (expression -> MINUS expression .)
    CLASS           reduce using rule 45 (expression -> MINUS expression .)
    TYPE_IDENTIFIER reduce using rule 45 (expression -> MINUS expression .)
    OBJECT_IDENTIFIER reduce using rule 45 (expression -> MINUS expression .)
    WHILE           reduce using rule 45 (expression -> MINUS expression .)
    LET             reduce using rule 45 (expression -> MINUS expression .)
    NOT             reduce using rule 45 (expression -> MINUS expression .)
    ISNULL          reduce using rule 45 (expression -> MINUS expression .)
    NEW             reduce using rule 45 (expression -> MINUS expression .)
    SELF            reduce using rule 45 (expression -> MINUS expression .)
    LPAR            reduce using rule 45 (expression -> MINUS expression .)
    error           reduce using rule 45 (expression -> MINUS expression .)
    IF              reduce using rule 45 (expression -> MINUS expression .)
    LBRACE          reduce using rule 45 (expression -> MINUS expression .)
    INTEGER_LITERAL reduce using rule 45 (expression -> MINUS expression .)
    string_literal  reduce using rule 45 (expression -> MINUS expression .)
    TRUE            reduce using rule 45 (expression -> MINUS expression .)
    FALSE           reduce using rule 45 (expression -> MINUS expression .)
    $end            reduce using rule 45 (expression -> MINUS expression .)
    RPAR            reduce using rule 45 (expression -> MINUS expression .)
    THEN            reduce using rule 45 (expression -> MINUS expression .)
    DO              reduce using rule 45 (expression -> MINUS expression .)
    COMMA           reduce using rule 45 (expression -> MINUS expression .)
    RBRACE          reduce using rule 45 (expression -> MINUS expression .)
    SEMICOLON       reduce using rule 45 (expression -> MINUS expression .)
    IN              reduce using rule 45 (expression -> MINUS expression .)
    ELSE            reduce using rule 45 (expression -> MINUS expression .)
    POW             shift and go to state 45
    DOT             shift and go to state 47

  ! POW             [ reduce using rule 45 (expression -> MINUS expression .) ]
  ! DOT             [ reduce using rule 45 (expression -> MINUS expression .) ]
  ! PLUS            [ shift and go to state 38 ]
  ! MINUS           [ shift and go to state 39 ]
  ! TIMES           [ shift and go to state 40 ]
  ! DIV             [ shift and go to state 41 ]
  ! EQUAL           [ shift and go to state 42 ]
  ! LOWER_EQUAL     [ shift and go to state 43 ]
  ! LOWER           [ shift and go to state 44 ]
  ! AND             [ shift and go to state 46 ]


state 61

    (46) expression -> ISNULL expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    PLUS            reduce using rule 46 (expression -> ISNULL expression .)
    MINUS           reduce using rule 46 (expression -> ISNULL expression .)
    TIMES           reduce using rule 46 (expression -> ISNULL expression .)
    DIV             reduce using rule 46 (expression -> ISNULL expression .)
    EQUAL           reduce using rule 46 (expression -> ISNULL expression .)
    LOWER_EQUAL     reduce using rule 46 (expression -> ISNULL expression .)
    LOWER           reduce using rule 46 (expression -> ISNULL expression .)
    AND             reduce using rule 46 (expression -> ISNULL expression .)
    CLASS           reduce using rule 46 (expression -> ISNULL expression .)
    TYPE_IDENTIFIER reduce using rule 46 (expression -> ISNULL expression .)
    OBJECT_IDENTIFIER reduce using rule 46 (expression -> ISNULL expression .)
    WHILE           reduce using rule 46 (expression -> ISNULL expression .)
    LET             reduce using rule 46 (expression -> ISNULL expression .)
    NOT             reduce using rule 46 (expression -> ISNULL expression .)
    ISNULL          reduce using rule 46 (expression -> ISNULL expression .)
    NEW             reduce using rule 46 (expression -> ISNULL expression .)
    SELF            reduce using rule 46 (expression -> ISNULL expression .)
    LPAR            reduce using rule 46 (expression -> ISNULL expression .)
    error           reduce using rule 46 (expression -> ISNULL expression .)
    IF              reduce using rule 46 (expression -> ISNULL expression .)
    LBRACE          reduce using rule 46 (expression -> ISNULL expression .)
    INTEGER_LITERAL reduce using rule 46 (expression -> ISNULL expression .)
    string_literal  reduce using rule 46 (expression -> ISNULL expression .)
    TRUE            reduce using rule 46 (expression -> ISNULL expression .)
    FALSE           reduce using rule 46 (expression -> ISNULL expression .)
    $end            reduce using rule 46 (expression -> ISNULL expression .)
    RPAR            reduce using rule 46 (expression -> ISNULL expression .)
    THEN            reduce using rule 46 (expression -> ISNULL expression .)
    DO              reduce using rule 46 (expression -> ISNULL expression .)
    COMMA           reduce using rule 46 (expression -> ISNULL expression .)
    RBRACE          reduce using rule 46 (expression -> ISNULL expression .)
    SEMICOLON       reduce using rule 46 (expression -> ISNULL expression .)
    IN              reduce using rule 46 (expression -> ISNULL expression .)
    ELSE            reduce using rule 46 (expression -> ISNULL expression .)
    POW             shift and go to state 45
    DOT             shift and go to state 47

  ! POW             [ reduce using rule 46 (expression -> ISNULL expression .) ]
  ! DOT             [ reduce using rule 46 (expression -> ISNULL expression .) ]
  ! PLUS            [ shift and go to state 38 ]
  ! MINUS           [ shift and go to state 39 ]
  ! TIMES           [ shift and go to state 40 ]
  ! DIV             [ shift and go to state 41 ]
  ! EQUAL           [ shift and go to state 42 ]
  ! LOWER_EQUAL     [ shift and go to state 43 ]
  ! LOWER           [ shift and go to state 44 ]
  ! AND             [ shift and go to state 46 ]


state 62

    (58) expression -> NEW TYPE_IDENTIFIER .

    PLUS            reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    MINUS           reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    TIMES           reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    DIV             reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    EQUAL           reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    LOWER_EQUAL     reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    LOWER           reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    POW             reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    AND             reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    DOT             reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    CLASS           reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    OBJECT_IDENTIFIER reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    WHILE           reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    LET             reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    NOT             reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    ISNULL          reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    NEW             reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    SELF            reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    LPAR            reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    error           reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    IF              reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    LBRACE          reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    INTEGER_LITERAL reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    string_literal  reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    TRUE            reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    FALSE           reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    $end            reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    RPAR            reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    THEN            reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    DO              reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    COMMA           reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    RBRACE          reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    SEMICOLON       reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    IN              reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)
    ELSE            reduce using rule 58 (expression -> NEW TYPE_IDENTIFIER .)


state 63

    (31) block -> LBRACE new_variables_scope . inblock RBRACE
    (32) inblock -> . inblock SEMICOLON expression
    (33) inblock -> . expression
    (34) inblock -> .
    (35) inblock -> . inblock error
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
    RBRACE          reduce using rule 34 (inblock -> .)
    SEMICOLON       reduce using rule 34 (inblock -> .)
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! error           [ reduce using rule 34 (inblock -> .) ]
  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    new_variables_scope            shift and go to state 12
    inblock                        shift and go to state 96
    expression                     shift and go to state 97
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 64

    (10) class -> CLASS new_class_scope class-body .

    CLASS           reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    TYPE_IDENTIFIER reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    OBJECT_IDENTIFIER reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    WHILE           reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    LET             reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    NOT             reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    MINUS           reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    ISNULL          reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    NEW             reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    SELF            reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    LPAR            reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    error           reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    IF              reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    LBRACE          reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    INTEGER_LITERAL reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    string_literal  reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    TRUE            reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    FALSE           reduce using rule 10 (class -> CLASS new_class_scope class-body .)
    $end            reduce using rule 10 (class -> CLASS new_class_scope class-body .)


state 65

    (11) class -> CLASS new_class_scope EXTENDS . TYPE_IDENTIFIER class-body

    TYPE_IDENTIFIER shift and go to state 98


state 66

    (13) class-body -> LBRACE . class-body-in RBRACE
    (14) class-body -> LBRACE . class-body-in error
    (15) class-body-in -> . class-body-in field
    (16) class-body-in -> . class-body-in method
    (17) class-body-in -> .

    RBRACE          reduce using rule 17 (class-body-in -> .)
    error           reduce using rule 17 (class-body-in -> .)
    OBJECT_IDENTIFIER reduce using rule 17 (class-body-in -> .)

    class-body-in                  shift and go to state 99

state 67

    (65) expression -> error expression RPAR .

    PLUS            reduce using rule 65 (expression -> error expression RPAR .)
    MINUS           reduce using rule 65 (expression -> error expression RPAR .)
    TIMES           reduce using rule 65 (expression -> error expression RPAR .)
    DIV             reduce using rule 65 (expression -> error expression RPAR .)
    EQUAL           reduce using rule 65 (expression -> error expression RPAR .)
    LOWER_EQUAL     reduce using rule 65 (expression -> error expression RPAR .)
    LOWER           reduce using rule 65 (expression -> error expression RPAR .)
    POW             reduce using rule 65 (expression -> error expression RPAR .)
    AND             reduce using rule 65 (expression -> error expression RPAR .)
    DOT             reduce using rule 65 (expression -> error expression RPAR .)
    CLASS           reduce using rule 65 (expression -> error expression RPAR .)
    TYPE_IDENTIFIER reduce using rule 65 (expression -> error expression RPAR .)
    OBJECT_IDENTIFIER reduce using rule 65 (expression -> error expression RPAR .)
    WHILE           reduce using rule 65 (expression -> error expression RPAR .)
    LET             reduce using rule 65 (expression -> error expression RPAR .)
    NOT             reduce using rule 65 (expression -> error expression RPAR .)
    ISNULL          reduce using rule 65 (expression -> error expression RPAR .)
    NEW             reduce using rule 65 (expression -> error expression RPAR .)
    SELF            reduce using rule 65 (expression -> error expression RPAR .)
    LPAR            reduce using rule 65 (expression -> error expression RPAR .)
    error           reduce using rule 65 (expression -> error expression RPAR .)
    IF              reduce using rule 65 (expression -> error expression RPAR .)
    LBRACE          reduce using rule 65 (expression -> error expression RPAR .)
    INTEGER_LITERAL reduce using rule 65 (expression -> error expression RPAR .)
    string_literal  reduce using rule 65 (expression -> error expression RPAR .)
    TRUE            reduce using rule 65 (expression -> error expression RPAR .)
    FALSE           reduce using rule 65 (expression -> error expression RPAR .)
    $end            reduce using rule 65 (expression -> error expression RPAR .)
    RPAR            reduce using rule 65 (expression -> error expression RPAR .)
    THEN            reduce using rule 65 (expression -> error expression RPAR .)
    DO              reduce using rule 65 (expression -> error expression RPAR .)
    COMMA           reduce using rule 65 (expression -> error expression RPAR .)
    RBRACE          reduce using rule 65 (expression -> error expression RPAR .)
    SEMICOLON       reduce using rule 65 (expression -> error expression RPAR .)
    IN              reduce using rule 65 (expression -> error expression RPAR .)
    ELSE            reduce using rule 65 (expression -> error expression RPAR .)


state 68

    (47) expression -> expression PLUS expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    PLUS            reduce using rule 47 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 47 (expression -> expression PLUS expression .)
    EQUAL           reduce using rule 47 (expression -> expression PLUS expression .)
    LOWER_EQUAL     reduce using rule 47 (expression -> expression PLUS expression .)
    LOWER           reduce using rule 47 (expression -> expression PLUS expression .)
    AND             reduce using rule 47 (expression -> expression PLUS expression .)
    CLASS           reduce using rule 47 (expression -> expression PLUS expression .)
    TYPE_IDENTIFIER reduce using rule 47 (expression -> expression PLUS expression .)
    OBJECT_IDENTIFIER reduce using rule 47 (expression -> expression PLUS expression .)
    WHILE           reduce using rule 47 (expression -> expression PLUS expression .)
    LET             reduce using rule 47 (expression -> expression PLUS expression .)
    NOT             reduce using rule 47 (expression -> expression PLUS expression .)
    ISNULL          reduce using rule 47 (expression -> expression PLUS expression .)
    NEW             reduce using rule 47 (expression -> expression PLUS expression .)
    SELF            reduce using rule 47 (expression -> expression PLUS expression .)
    LPAR            reduce using rule 47 (expression -> expression PLUS expression .)
    error           reduce using rule 47 (expression -> expression PLUS expression .)
    IF              reduce using rule 47 (expression -> expression PLUS expression .)
    LBRACE          reduce using rule 47 (expression -> expression PLUS expression .)
    INTEGER_LITERAL reduce using rule 47 (expression -> expression PLUS expression .)
    string_literal  reduce using rule 47 (expression -> expression PLUS expression .)
    TRUE            reduce using rule 47 (expression -> expression PLUS expression .)
    FALSE           reduce using rule 47 (expression -> expression PLUS expression .)
    $end            reduce using rule 47 (expression -> expression PLUS expression .)
    RPAR            reduce using rule 47 (expression -> expression PLUS expression .)
    THEN            reduce using rule 47 (expression -> expression PLUS expression .)
    DO              reduce using rule 47 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 47 (expression -> expression PLUS expression .)
    RBRACE          reduce using rule 47 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 47 (expression -> expression PLUS expression .)
    IN              reduce using rule 47 (expression -> expression PLUS expression .)
    ELSE            reduce using rule 47 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    POW             shift and go to state 45
    DOT             shift and go to state 47

  ! TIMES           [ reduce using rule 47 (expression -> expression PLUS expression .) ]
  ! DIV             [ reduce using rule 47 (expression -> expression PLUS expression .) ]
  ! POW             [ reduce using rule 47 (expression -> expression PLUS expression .) ]
  ! DOT             [ reduce using rule 47 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 38 ]
  ! MINUS           [ shift and go to state 39 ]
  ! EQUAL           [ shift and go to state 42 ]
  ! LOWER_EQUAL     [ shift and go to state 43 ]
  ! LOWER           [ shift and go to state 44 ]
  ! AND             [ shift and go to state 46 ]


state 69

    (48) expression -> expression MINUS expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    PLUS            reduce using rule 48 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 48 (expression -> expression MINUS expression .)
    EQUAL           reduce using rule 48 (expression -> expression MINUS expression .)
    LOWER_EQUAL     reduce using rule 48 (expression -> expression MINUS expression .)
    LOWER           reduce using rule 48 (expression -> expression MINUS expression .)
    AND             reduce using rule 48 (expression -> expression MINUS expression .)
    CLASS           reduce using rule 48 (expression -> expression MINUS expression .)
    TYPE_IDENTIFIER reduce using rule 48 (expression -> expression MINUS expression .)
    OBJECT_IDENTIFIER reduce using rule 48 (expression -> expression MINUS expression .)
    WHILE           reduce using rule 48 (expression -> expression MINUS expression .)
    LET             reduce using rule 48 (expression -> expression MINUS expression .)
    NOT             reduce using rule 48 (expression -> expression MINUS expression .)
    ISNULL          reduce using rule 48 (expression -> expression MINUS expression .)
    NEW             reduce using rule 48 (expression -> expression MINUS expression .)
    SELF            reduce using rule 48 (expression -> expression MINUS expression .)
    LPAR            reduce using rule 48 (expression -> expression MINUS expression .)
    error           reduce using rule 48 (expression -> expression MINUS expression .)
    IF              reduce using rule 48 (expression -> expression MINUS expression .)
    LBRACE          reduce using rule 48 (expression -> expression MINUS expression .)
    INTEGER_LITERAL reduce using rule 48 (expression -> expression MINUS expression .)
    string_literal  reduce using rule 48 (expression -> expression MINUS expression .)
    TRUE            reduce using rule 48 (expression -> expression MINUS expression .)
    FALSE           reduce using rule 48 (expression -> expression MINUS expression .)
    $end            reduce using rule 48 (expression -> expression MINUS expression .)
    RPAR            reduce using rule 48 (expression -> expression MINUS expression .)
    THEN            reduce using rule 48 (expression -> expression MINUS expression .)
    DO              reduce using rule 48 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 48 (expression -> expression MINUS expression .)
    RBRACE          reduce using rule 48 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 48 (expression -> expression MINUS expression .)
    IN              reduce using rule 48 (expression -> expression MINUS expression .)
    ELSE            reduce using rule 48 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    POW             shift and go to state 45
    DOT             shift and go to state 47

  ! TIMES           [ reduce using rule 48 (expression -> expression MINUS expression .) ]
  ! DIV             [ reduce using rule 48 (expression -> expression MINUS expression .) ]
  ! POW             [ reduce using rule 48 (expression -> expression MINUS expression .) ]
  ! DOT             [ reduce using rule 48 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 38 ]
  ! MINUS           [ shift and go to state 39 ]
  ! EQUAL           [ shift and go to state 42 ]
  ! LOWER_EQUAL     [ shift and go to state 43 ]
  ! LOWER           [ shift and go to state 44 ]
  ! AND             [ shift and go to state 46 ]


state 70

    (49) expression -> expression TIMES expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    PLUS            reduce using rule 49 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 49 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 49 (expression -> expression TIMES expression .)
    DIV             reduce using rule 49 (expression -> expression TIMES expression .)
    EQUAL           reduce using rule 49 (expression -> expression TIMES expression .)
    LOWER_EQUAL     reduce using rule 49 (expression -> expression TIMES expression .)
    LOWER           reduce using rule 49 (expression -> expression TIMES expression .)
    AND             reduce using rule 49 (expression -> expression TIMES expression .)
    CLASS           reduce using rule 49 (expression -> expression TIMES expression .)
    TYPE_IDENTIFIER reduce using rule 49 (expression -> expression TIMES expression .)
    OBJECT_IDENTIFIER reduce using rule 49 (expression -> expression TIMES expression .)
    WHILE           reduce using rule 49 (expression -> expression TIMES expression .)
    LET             reduce using rule 49 (expression -> expression TIMES expression .)
    NOT             reduce using rule 49 (expression -> expression TIMES expression .)
    ISNULL          reduce using rule 49 (expression -> expression TIMES expression .)
    NEW             reduce using rule 49 (expression -> expression TIMES expression .)
    SELF            reduce using rule 49 (expression -> expression TIMES expression .)
    LPAR            reduce using rule 49 (expression -> expression TIMES expression .)
    error           reduce using rule 49 (expression -> expression TIMES expression .)
    IF              reduce using rule 49 (expression -> expression TIMES expression .)
    LBRACE          reduce using rule 49 (expression -> expression TIMES expression .)
    INTEGER_LITERAL reduce using rule 49 (expression -> expression TIMES expression .)
    string_literal  reduce using rule 49 (expression -> expression TIMES expression .)
    TRUE            reduce using rule 49 (expression -> expression TIMES expression .)
    FALSE           reduce using rule 49 (expression -> expression TIMES expression .)
    $end            reduce using rule 49 (expression -> expression TIMES expression .)
    RPAR            reduce using rule 49 (expression -> expression TIMES expression .)
    THEN            reduce using rule 49 (expression -> expression TIMES expression .)
    DO              reduce using rule 49 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 49 (expression -> expression TIMES expression .)
    RBRACE          reduce using rule 49 (expression -> expression TIMES expression .)
    SEMICOLON       reduce using rule 49 (expression -> expression TIMES expression .)
    IN              reduce using rule 49 (expression -> expression TIMES expression .)
    ELSE            reduce using rule 49 (expression -> expression TIMES expression .)
    POW             shift and go to state 45
    DOT             shift and go to state 47

  ! POW             [ reduce using rule 49 (expression -> expression TIMES expression .) ]
  ! DOT             [ reduce using rule 49 (expression -> expression TIMES expression .) ]
  ! PLUS            [ shift and go to state 38 ]
  ! MINUS           [ shift and go to state 39 ]
  ! TIMES           [ shift and go to state 40 ]
  ! DIV             [ shift and go to state 41 ]
  ! EQUAL           [ shift and go to state 42 ]
  ! LOWER_EQUAL     [ shift and go to state 43 ]
  ! LOWER           [ shift and go to state 44 ]
  ! AND             [ shift and go to state 46 ]


state 71

    (50) expression -> expression DIV expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    PLUS            reduce using rule 50 (expression -> expression DIV expression .)
    MINUS           reduce using rule 50 (expression -> expression DIV expression .)
    TIMES           reduce using rule 50 (expression -> expression DIV expression .)
    DIV             reduce using rule 50 (expression -> expression DIV expression .)
    EQUAL           reduce using rule 50 (expression -> expression DIV expression .)
    LOWER_EQUAL     reduce using rule 50 (expression -> expression DIV expression .)
    LOWER           reduce using rule 50 (expression -> expression DIV expression .)
    AND             reduce using rule 50 (expression -> expression DIV expression .)
    CLASS           reduce using rule 50 (expression -> expression DIV expression .)
    TYPE_IDENTIFIER reduce using rule 50 (expression -> expression DIV expression .)
    OBJECT_IDENTIFIER reduce using rule 50 (expression -> expression DIV expression .)
    WHILE           reduce using rule 50 (expression -> expression DIV expression .)
    LET             reduce using rule 50 (expression -> expression DIV expression .)
    NOT             reduce using rule 50 (expression -> expression DIV expression .)
    ISNULL          reduce using rule 50 (expression -> expression DIV expression .)
    NEW             reduce using rule 50 (expression -> expression DIV expression .)
    SELF            reduce using rule 50 (expression -> expression DIV expression .)
    LPAR            reduce using rule 50 (expression -> expression DIV expression .)
    error           reduce using rule 50 (expression -> expression DIV expression .)
    IF              reduce using rule 50 (expression -> expression DIV expression .)
    LBRACE          reduce using rule 50 (expression -> expression DIV expression .)
    INTEGER_LITERAL reduce using rule 50 (expression -> expression DIV expression .)
    string_literal  reduce using rule 50 (expression -> expression DIV expression .)
    TRUE            reduce using rule 50 (expression -> expression DIV expression .)
    FALSE           reduce using rule 50 (expression -> expression DIV expression .)
    $end            reduce using rule 50 (expression -> expression DIV expression .)
    RPAR            reduce using rule 50 (expression -> expression DIV expression .)
    THEN            reduce using rule 50 (expression -> expression DIV expression .)
    DO              reduce using rule 50 (expression -> expression DIV expression .)
    COMMA           reduce using rule 50 (expression -> expression DIV expression .)
    RBRACE          reduce using rule 50 (expression -> expression DIV expression .)
    SEMICOLON       reduce using rule 50 (expression -> expression DIV expression .)
    IN              reduce using rule 50 (expression -> expression DIV expression .)
    ELSE            reduce using rule 50 (expression -> expression DIV expression .)
    POW             shift and go to state 45
    DOT             shift and go to state 47

  ! POW             [ reduce using rule 50 (expression -> expression DIV expression .) ]
  ! DOT             [ reduce using rule 50 (expression -> expression DIV expression .) ]
  ! PLUS            [ shift and go to state 38 ]
  ! MINUS           [ shift and go to state 39 ]
  ! TIMES           [ shift and go to state 40 ]
  ! DIV             [ shift and go to state 41 ]
  ! EQUAL           [ shift and go to state 42 ]
  ! LOWER_EQUAL     [ shift and go to state 43 ]
  ! LOWER           [ shift and go to state 44 ]
  ! AND             [ shift and go to state 46 ]


state 72

    (51) expression -> expression EQUAL expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    EQUAL           reduce using rule 51 (expression -> expression EQUAL expression .)
    LOWER_EQUAL     reduce using rule 51 (expression -> expression EQUAL expression .)
    LOWER           reduce using rule 51 (expression -> expression EQUAL expression .)
    AND             reduce using rule 51 (expression -> expression EQUAL expression .)
    CLASS           reduce using rule 51 (expression -> expression EQUAL expression .)
    TYPE_IDENTIFIER reduce using rule 51 (expression -> expression EQUAL expression .)
    OBJECT_IDENTIFIER reduce using rule 51 (expression -> expression EQUAL expression .)
    WHILE           reduce using rule 51 (expression -> expression EQUAL expression .)
    LET             reduce using rule 51 (expression -> expression EQUAL expression .)
    NOT             reduce using rule 51 (expression -> expression EQUAL expression .)
    ISNULL          reduce using rule 51 (expression -> expression EQUAL expression .)
    NEW             reduce using rule 51 (expression -> expression EQUAL expression .)
    SELF            reduce using rule 51 (expression -> expression EQUAL expression .)
    LPAR            reduce using rule 51 (expression -> expression EQUAL expression .)
    error           reduce using rule 51 (expression -> expression EQUAL expression .)
    IF              reduce using rule 51 (expression -> expression EQUAL expression .)
    LBRACE          reduce using rule 51 (expression -> expression EQUAL expression .)
    INTEGER_LITERAL reduce using rule 51 (expression -> expression EQUAL expression .)
    string_literal  reduce using rule 51 (expression -> expression EQUAL expression .)
    TRUE            reduce using rule 51 (expression -> expression EQUAL expression .)
    FALSE           reduce using rule 51 (expression -> expression EQUAL expression .)
    $end            reduce using rule 51 (expression -> expression EQUAL expression .)
    RPAR            reduce using rule 51 (expression -> expression EQUAL expression .)
    THEN            reduce using rule 51 (expression -> expression EQUAL expression .)
    DO              reduce using rule 51 (expression -> expression EQUAL expression .)
    COMMA           reduce using rule 51 (expression -> expression EQUAL expression .)
    RBRACE          reduce using rule 51 (expression -> expression EQUAL expression .)
    SEMICOLON       reduce using rule 51 (expression -> expression EQUAL expression .)
    IN              reduce using rule 51 (expression -> expression EQUAL expression .)
    ELSE            reduce using rule 51 (expression -> expression EQUAL expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    POW             shift and go to state 45
    DOT             shift and go to state 47

  ! PLUS            [ reduce using rule 51 (expression -> expression EQUAL expression .) ]
  ! MINUS           [ reduce using rule 51 (expression -> expression EQUAL expression .) ]
  ! TIMES           [ reduce using rule 51 (expression -> expression EQUAL expression .) ]
  ! DIV             [ reduce using rule 51 (expression -> expression EQUAL expression .) ]
  ! POW             [ reduce using rule 51 (expression -> expression EQUAL expression .) ]
  ! DOT             [ reduce using rule 51 (expression -> expression EQUAL expression .) ]
  ! EQUAL           [ shift and go to state 42 ]
  ! LOWER_EQUAL     [ shift and go to state 43 ]
  ! LOWER           [ shift and go to state 44 ]
  ! AND             [ shift and go to state 46 ]


state 73

    (52) expression -> expression LOWER_EQUAL expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    EQUAL           reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    LOWER_EQUAL     reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    LOWER           reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    AND             reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    CLASS           reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    TYPE_IDENTIFIER reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    OBJECT_IDENTIFIER reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    WHILE           reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    LET             reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    NOT             reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    ISNULL          reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    NEW             reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    SELF            reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    LPAR            reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    error           reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    IF              reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    LBRACE          reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    INTEGER_LITERAL reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    string_literal  reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    TRUE            reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    FALSE           reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    $end            reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    RPAR            reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    THEN            reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    DO              reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    COMMA           reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    RBRACE          reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    SEMICOLON       reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    IN              reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    ELSE            reduce using rule 52 (expression -> expression LOWER_EQUAL expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    POW             shift and go to state 45
    DOT             shift and go to state 47

  ! PLUS            [ reduce using rule 52 (expression -> expression LOWER_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 52 (expression -> expression LOWER_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 52 (expression -> expression LOWER_EQUAL expression .) ]
  ! DIV             [ reduce using rule 52 (expression -> expression LOWER_EQUAL expression .) ]
  ! POW             [ reduce using rule 52 (expression -> expression LOWER_EQUAL expression .) ]
  ! DOT             [ reduce using rule 52 (expression -> expression LOWER_EQUAL expression .) ]
  ! EQUAL           [ shift and go to state 42 ]
  ! LOWER_EQUAL     [ shift and go to state 43 ]
  ! LOWER           [ shift and go to state 44 ]
  ! AND             [ shift and go to state 46 ]


state 74

    (53) expression -> expression LOWER expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    EQUAL           reduce using rule 53 (expression -> expression LOWER expression .)
    LOWER_EQUAL     reduce using rule 53 (expression -> expression LOWER expression .)
    LOWER           reduce using rule 53 (expression -> expression LOWER expression .)
    AND             reduce using rule 53 (expression -> expression LOWER expression .)
    CLASS           reduce using rule 53 (expression -> expression LOWER expression .)
    TYPE_IDENTIFIER reduce using rule 53 (expression -> expression LOWER expression .)
    OBJECT_IDENTIFIER reduce using rule 53 (expression -> expression LOWER expression .)
    WHILE           reduce using rule 53 (expression -> expression LOWER expression .)
    LET             reduce using rule 53 (expression -> expression LOWER expression .)
    NOT             reduce using rule 53 (expression -> expression LOWER expression .)
    ISNULL          reduce using rule 53 (expression -> expression LOWER expression .)
    NEW             reduce using rule 53 (expression -> expression LOWER expression .)
    SELF            reduce using rule 53 (expression -> expression LOWER expression .)
    LPAR            reduce using rule 53 (expression -> expression LOWER expression .)
    error           reduce using rule 53 (expression -> expression LOWER expression .)
    IF              reduce using rule 53 (expression -> expression LOWER expression .)
    LBRACE          reduce using rule 53 (expression -> expression LOWER expression .)
    INTEGER_LITERAL reduce using rule 53 (expression -> expression LOWER expression .)
    string_literal  reduce using rule 53 (expression -> expression LOWER expression .)
    TRUE            reduce using rule 53 (expression -> expression LOWER expression .)
    FALSE           reduce using rule 53 (expression -> expression LOWER expression .)
    $end            reduce using rule 53 (expression -> expression LOWER expression .)
    RPAR            reduce using rule 53 (expression -> expression LOWER expression .)
    THEN            reduce using rule 53 (expression -> expression LOWER expression .)
    DO              reduce using rule 53 (expression -> expression LOWER expression .)
    COMMA           reduce using rule 53 (expression -> expression LOWER expression .)
    RBRACE          reduce using rule 53 (expression -> expression LOWER expression .)
    SEMICOLON       reduce using rule 53 (expression -> expression LOWER expression .)
    IN              reduce using rule 53 (expression -> expression LOWER expression .)
    ELSE            reduce using rule 53 (expression -> expression LOWER expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    POW             shift and go to state 45
    DOT             shift and go to state 47

  ! PLUS            [ reduce using rule 53 (expression -> expression LOWER expression .) ]
  ! MINUS           [ reduce using rule 53 (expression -> expression LOWER expression .) ]
  ! TIMES           [ reduce using rule 53 (expression -> expression LOWER expression .) ]
  ! DIV             [ reduce using rule 53 (expression -> expression LOWER expression .) ]
  ! POW             [ reduce using rule 53 (expression -> expression LOWER expression .) ]
  ! DOT             [ reduce using rule 53 (expression -> expression LOWER expression .) ]
  ! EQUAL           [ shift and go to state 42 ]
  ! LOWER_EQUAL     [ shift and go to state 43 ]
  ! LOWER           [ shift and go to state 44 ]
  ! AND             [ shift and go to state 46 ]


state 75

    (54) expression -> expression POW expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    PLUS            reduce using rule 54 (expression -> expression POW expression .)
    MINUS           reduce using rule 54 (expression -> expression POW expression .)
    TIMES           reduce using rule 54 (expression -> expression POW expression .)
    DIV             reduce using rule 54 (expression -> expression POW expression .)
    EQUAL           reduce using rule 54 (expression -> expression POW expression .)
    LOWER_EQUAL     reduce using rule 54 (expression -> expression POW expression .)
    LOWER           reduce using rule 54 (expression -> expression POW expression .)
    AND             reduce using rule 54 (expression -> expression POW expression .)
    CLASS           reduce using rule 54 (expression -> expression POW expression .)
    TYPE_IDENTIFIER reduce using rule 54 (expression -> expression POW expression .)
    OBJECT_IDENTIFIER reduce using rule 54 (expression -> expression POW expression .)
    WHILE           reduce using rule 54 (expression -> expression POW expression .)
    LET             reduce using rule 54 (expression -> expression POW expression .)
    NOT             reduce using rule 54 (expression -> expression POW expression .)
    ISNULL          reduce using rule 54 (expression -> expression POW expression .)
    NEW             reduce using rule 54 (expression -> expression POW expression .)
    SELF            reduce using rule 54 (expression -> expression POW expression .)
    LPAR            reduce using rule 54 (expression -> expression POW expression .)
    error           reduce using rule 54 (expression -> expression POW expression .)
    IF              reduce using rule 54 (expression -> expression POW expression .)
    LBRACE          reduce using rule 54 (expression -> expression POW expression .)
    INTEGER_LITERAL reduce using rule 54 (expression -> expression POW expression .)
    string_literal  reduce using rule 54 (expression -> expression POW expression .)
    TRUE            reduce using rule 54 (expression -> expression POW expression .)
    FALSE           reduce using rule 54 (expression -> expression POW expression .)
    $end            reduce using rule 54 (expression -> expression POW expression .)
    RPAR            reduce using rule 54 (expression -> expression POW expression .)
    THEN            reduce using rule 54 (expression -> expression POW expression .)
    DO              reduce using rule 54 (expression -> expression POW expression .)
    COMMA           reduce using rule 54 (expression -> expression POW expression .)
    RBRACE          reduce using rule 54 (expression -> expression POW expression .)
    SEMICOLON       reduce using rule 54 (expression -> expression POW expression .)
    IN              reduce using rule 54 (expression -> expression POW expression .)
    ELSE            reduce using rule 54 (expression -> expression POW expression .)
    POW             shift and go to state 45
    DOT             shift and go to state 47

  ! POW             [ reduce using rule 54 (expression -> expression POW expression .) ]
  ! DOT             [ reduce using rule 54 (expression -> expression POW expression .) ]
  ! PLUS            [ shift and go to state 38 ]
  ! MINUS           [ shift and go to state 39 ]
  ! TIMES           [ shift and go to state 40 ]
  ! DIV             [ shift and go to state 41 ]
  ! EQUAL           [ shift and go to state 42 ]
  ! LOWER_EQUAL     [ shift and go to state 43 ]
  ! LOWER           [ shift and go to state 44 ]
  ! AND             [ shift and go to state 46 ]


state 76

    (55) expression -> expression AND expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    AND             reduce using rule 55 (expression -> expression AND expression .)
    CLASS           reduce using rule 55 (expression -> expression AND expression .)
    TYPE_IDENTIFIER reduce using rule 55 (expression -> expression AND expression .)
    OBJECT_IDENTIFIER reduce using rule 55 (expression -> expression AND expression .)
    WHILE           reduce using rule 55 (expression -> expression AND expression .)
    LET             reduce using rule 55 (expression -> expression AND expression .)
    NOT             reduce using rule 55 (expression -> expression AND expression .)
    ISNULL          reduce using rule 55 (expression -> expression AND expression .)
    NEW             reduce using rule 55 (expression -> expression AND expression .)
    SELF            reduce using rule 55 (expression -> expression AND expression .)
    LPAR            reduce using rule 55 (expression -> expression AND expression .)
    error           reduce using rule 55 (expression -> expression AND expression .)
    IF              reduce using rule 55 (expression -> expression AND expression .)
    LBRACE          reduce using rule 55 (expression -> expression AND expression .)
    INTEGER_LITERAL reduce using rule 55 (expression -> expression AND expression .)
    string_literal  reduce using rule 55 (expression -> expression AND expression .)
    TRUE            reduce using rule 55 (expression -> expression AND expression .)
    FALSE           reduce using rule 55 (expression -> expression AND expression .)
    $end            reduce using rule 55 (expression -> expression AND expression .)
    RPAR            reduce using rule 55 (expression -> expression AND expression .)
    THEN            reduce using rule 55 (expression -> expression AND expression .)
    DO              reduce using rule 55 (expression -> expression AND expression .)
    COMMA           reduce using rule 55 (expression -> expression AND expression .)
    RBRACE          reduce using rule 55 (expression -> expression AND expression .)
    SEMICOLON       reduce using rule 55 (expression -> expression AND expression .)
    IN              reduce using rule 55 (expression -> expression AND expression .)
    ELSE            reduce using rule 55 (expression -> expression AND expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    DOT             shift and go to state 47

  ! PLUS            [ reduce using rule 55 (expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 55 (expression -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 55 (expression -> expression AND expression .) ]
  ! DIV             [ reduce using rule 55 (expression -> expression AND expression .) ]
  ! EQUAL           [ reduce using rule 55 (expression -> expression AND expression .) ]
  ! LOWER_EQUAL     [ reduce using rule 55 (expression -> expression AND expression .) ]
  ! LOWER           [ reduce using rule 55 (expression -> expression AND expression .) ]
  ! POW             [ reduce using rule 55 (expression -> expression AND expression .) ]
  ! DOT             [ reduce using rule 55 (expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 46 ]


state 77

    (57) expression -> expression DOT OBJECT_IDENTIFIER . LPAR args RPAR

    LPAR            shift and go to state 100


state 78

    (18) field -> OBJECT_IDENTIFIER COLON type . SEMICOLON
    (19) field -> OBJECT_IDENTIFIER COLON type . ASSIGN expression SEMICOLON

    SEMICOLON       shift and go to state 101
    ASSIGN          shift and go to state 102


state 79

    (22) type -> TYPE_IDENTIFIER .

    SEMICOLON       reduce using rule 22 (type -> TYPE_IDENTIFIER .)
    ASSIGN          reduce using rule 22 (type -> TYPE_IDENTIFIER .)
    IN              reduce using rule 22 (type -> TYPE_IDENTIFIER .)
    RPAR            reduce using rule 22 (type -> TYPE_IDENTIFIER .)
    COMMA           reduce using rule 22 (type -> TYPE_IDENTIFIER .)
    LBRACE          reduce using rule 22 (type -> TYPE_IDENTIFIER .)


state 80

    (23) type -> INT32 .

    SEMICOLON       reduce using rule 23 (type -> INT32 .)
    ASSIGN          reduce using rule 23 (type -> INT32 .)
    IN              reduce using rule 23 (type -> INT32 .)
    RPAR            reduce using rule 23 (type -> INT32 .)
    COMMA           reduce using rule 23 (type -> INT32 .)
    LBRACE          reduce using rule 23 (type -> INT32 .)


state 81

    (24) type -> BOOL .

    SEMICOLON       reduce using rule 24 (type -> BOOL .)
    ASSIGN          reduce using rule 24 (type -> BOOL .)
    IN              reduce using rule 24 (type -> BOOL .)
    RPAR            reduce using rule 24 (type -> BOOL .)
    COMMA           reduce using rule 24 (type -> BOOL .)
    LBRACE          reduce using rule 24 (type -> BOOL .)


state 82

    (25) type -> STRING .

    SEMICOLON       reduce using rule 25 (type -> STRING .)
    ASSIGN          reduce using rule 25 (type -> STRING .)
    IN              reduce using rule 25 (type -> STRING .)
    RPAR            reduce using rule 25 (type -> STRING .)
    COMMA           reduce using rule 25 (type -> STRING .)
    LBRACE          reduce using rule 25 (type -> STRING .)


state 83

    (26) type -> UNIT .

    SEMICOLON       reduce using rule 26 (type -> UNIT .)
    ASSIGN          reduce using rule 26 (type -> UNIT .)
    IN              reduce using rule 26 (type -> UNIT .)
    RPAR            reduce using rule 26 (type -> UNIT .)
    COMMA           reduce using rule 26 (type -> UNIT .)
    LBRACE          reduce using rule 26 (type -> UNIT .)


state 84

    (42) expression -> OBJECT_IDENTIFIER ASSIGN get_type . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 103
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 85

    (20) method -> OBJECT_IDENTIFIER new_variables_scope LPAR . formals RPAR COLON type block
    (27) formals -> . formal
    (28) formals -> . formals COMMA formal
    (29) formals -> .
    (30) formal -> . OBJECT_IDENTIFIER COLON type

    RPAR            reduce using rule 29 (formals -> .)
    COMMA           reduce using rule 29 (formals -> .)
    OBJECT_IDENTIFIER shift and go to state 104

    formals                        shift and go to state 105
    formal                         shift and go to state 106

state 86

    (56) expression -> OBJECT_IDENTIFIER LPAR args . RPAR
    (69) args -> args . COMMA expression

    RPAR            shift and go to state 107
    COMMA           shift and go to state 108


state 87

    (70) args -> expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    RPAR            reduce using rule 70 (args -> expression .)
    COMMA           reduce using rule 70 (args -> expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47


state 88

    (36) expression -> new_variables_scope IF expression . THEN expression
    (37) expression -> new_variables_scope IF expression . THEN expression ELSE expression
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    THEN            shift and go to state 109
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47


state 89

    (63) expression -> LPAR expression RPAR .

    PLUS            reduce using rule 63 (expression -> LPAR expression RPAR .)
    MINUS           reduce using rule 63 (expression -> LPAR expression RPAR .)
    TIMES           reduce using rule 63 (expression -> LPAR expression RPAR .)
    DIV             reduce using rule 63 (expression -> LPAR expression RPAR .)
    EQUAL           reduce using rule 63 (expression -> LPAR expression RPAR .)
    LOWER_EQUAL     reduce using rule 63 (expression -> LPAR expression RPAR .)
    LOWER           reduce using rule 63 (expression -> LPAR expression RPAR .)
    POW             reduce using rule 63 (expression -> LPAR expression RPAR .)
    AND             reduce using rule 63 (expression -> LPAR expression RPAR .)
    DOT             reduce using rule 63 (expression -> LPAR expression RPAR .)
    CLASS           reduce using rule 63 (expression -> LPAR expression RPAR .)
    TYPE_IDENTIFIER reduce using rule 63 (expression -> LPAR expression RPAR .)
    OBJECT_IDENTIFIER reduce using rule 63 (expression -> LPAR expression RPAR .)
    WHILE           reduce using rule 63 (expression -> LPAR expression RPAR .)
    LET             reduce using rule 63 (expression -> LPAR expression RPAR .)
    NOT             reduce using rule 63 (expression -> LPAR expression RPAR .)
    ISNULL          reduce using rule 63 (expression -> LPAR expression RPAR .)
    NEW             reduce using rule 63 (expression -> LPAR expression RPAR .)
    SELF            reduce using rule 63 (expression -> LPAR expression RPAR .)
    LPAR            reduce using rule 63 (expression -> LPAR expression RPAR .)
    error           reduce using rule 63 (expression -> LPAR expression RPAR .)
    IF              reduce using rule 63 (expression -> LPAR expression RPAR .)
    LBRACE          reduce using rule 63 (expression -> LPAR expression RPAR .)
    INTEGER_LITERAL reduce using rule 63 (expression -> LPAR expression RPAR .)
    string_literal  reduce using rule 63 (expression -> LPAR expression RPAR .)
    TRUE            reduce using rule 63 (expression -> LPAR expression RPAR .)
    FALSE           reduce using rule 63 (expression -> LPAR expression RPAR .)
    $end            reduce using rule 63 (expression -> LPAR expression RPAR .)
    RPAR            reduce using rule 63 (expression -> LPAR expression RPAR .)
    THEN            reduce using rule 63 (expression -> LPAR expression RPAR .)
    DO              reduce using rule 63 (expression -> LPAR expression RPAR .)
    COMMA           reduce using rule 63 (expression -> LPAR expression RPAR .)
    RBRACE          reduce using rule 63 (expression -> LPAR expression RPAR .)
    SEMICOLON       reduce using rule 63 (expression -> LPAR expression RPAR .)
    IN              reduce using rule 63 (expression -> LPAR expression RPAR .)
    ELSE            reduce using rule 63 (expression -> LPAR expression RPAR .)


state 90

    (64) expression -> LPAR expression error .

    PLUS            reduce using rule 64 (expression -> LPAR expression error .)
    MINUS           reduce using rule 64 (expression -> LPAR expression error .)
    TIMES           reduce using rule 64 (expression -> LPAR expression error .)
    DIV             reduce using rule 64 (expression -> LPAR expression error .)
    EQUAL           reduce using rule 64 (expression -> LPAR expression error .)
    LOWER_EQUAL     reduce using rule 64 (expression -> LPAR expression error .)
    LOWER           reduce using rule 64 (expression -> LPAR expression error .)
    POW             reduce using rule 64 (expression -> LPAR expression error .)
    AND             reduce using rule 64 (expression -> LPAR expression error .)
    DOT             reduce using rule 64 (expression -> LPAR expression error .)
    CLASS           reduce using rule 64 (expression -> LPAR expression error .)
    TYPE_IDENTIFIER reduce using rule 64 (expression -> LPAR expression error .)
    OBJECT_IDENTIFIER reduce using rule 64 (expression -> LPAR expression error .)
    WHILE           reduce using rule 64 (expression -> LPAR expression error .)
    LET             reduce using rule 64 (expression -> LPAR expression error .)
    NOT             reduce using rule 64 (expression -> LPAR expression error .)
    ISNULL          reduce using rule 64 (expression -> LPAR expression error .)
    NEW             reduce using rule 64 (expression -> LPAR expression error .)
    SELF            reduce using rule 64 (expression -> LPAR expression error .)
    LPAR            reduce using rule 64 (expression -> LPAR expression error .)
    error           reduce using rule 64 (expression -> LPAR expression error .)
    IF              reduce using rule 64 (expression -> LPAR expression error .)
    LBRACE          reduce using rule 64 (expression -> LPAR expression error .)
    INTEGER_LITERAL reduce using rule 64 (expression -> LPAR expression error .)
    string_literal  reduce using rule 64 (expression -> LPAR expression error .)
    TRUE            reduce using rule 64 (expression -> LPAR expression error .)
    FALSE           reduce using rule 64 (expression -> LPAR expression error .)
    $end            reduce using rule 64 (expression -> LPAR expression error .)
    RPAR            reduce using rule 64 (expression -> LPAR expression error .)
    THEN            reduce using rule 64 (expression -> LPAR expression error .)
    DO              reduce using rule 64 (expression -> LPAR expression error .)
    COMMA           reduce using rule 64 (expression -> LPAR expression error .)
    RBRACE          reduce using rule 64 (expression -> LPAR expression error .)
    SEMICOLON       reduce using rule 64 (expression -> LPAR expression error .)
    IN              reduce using rule 64 (expression -> LPAR expression error .)
    ELSE            reduce using rule 64 (expression -> LPAR expression error .)


state 91

    (68) expression -> IF expression THEN . expression SEMICOLON error
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 110
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 92

    (38) expression -> WHILE expression DO . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 111
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 93

    (39) expression -> LET let_type IN . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 112
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 94

    (40) expression -> LET let_type ASSIGN . expression IN expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 113
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 95

    (41) let_type -> OBJECT_IDENTIFIER COLON . type
    (22) type -> . TYPE_IDENTIFIER
    (23) type -> . INT32
    (24) type -> . BOOL
    (25) type -> . STRING
    (26) type -> . UNIT

    TYPE_IDENTIFIER shift and go to state 79
    INT32           shift and go to state 80
    BOOL            shift and go to state 81
    STRING          shift and go to state 82
    UNIT            shift and go to state 83

    type                           shift and go to state 114

state 96

    (31) block -> LBRACE new_variables_scope inblock . RBRACE
    (32) inblock -> inblock . SEMICOLON expression
    (35) inblock -> inblock . error

    RBRACE          shift and go to state 115
    SEMICOLON       shift and go to state 116
    error           shift and go to state 117


state 97

    (33) inblock -> expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    RBRACE          reduce using rule 33 (inblock -> expression .)
    SEMICOLON       reduce using rule 33 (inblock -> expression .)
    error           reduce using rule 33 (inblock -> expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47


state 98

    (11) class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER . class-body
    (13) class-body -> . LBRACE class-body-in RBRACE
    (14) class-body -> . LBRACE class-body-in error

    LBRACE          shift and go to state 66

    class-body                     shift and go to state 118

state 99

    (13) class-body -> LBRACE class-body-in . RBRACE
    (14) class-body -> LBRACE class-body-in . error
    (15) class-body-in -> class-body-in . field
    (16) class-body-in -> class-body-in . method
    (18) field -> . OBJECT_IDENTIFIER COLON type SEMICOLON
    (19) field -> . OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON
    (20) method -> . OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block

    RBRACE          shift and go to state 119
    error           shift and go to state 120
    OBJECT_IDENTIFIER shift and go to state 123

    field                          shift and go to state 121
    method                         shift and go to state 122

state 100

    (57) expression -> expression DOT OBJECT_IDENTIFIER LPAR . args RPAR
    (69) args -> . args COMMA expression
    (70) args -> . expression
    (71) args -> .
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    RPAR            reduce using rule 71 (args -> .)
    COMMA           reduce using rule 71 (args -> .)
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 87
    args                           shift and go to state 124
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 101

    (18) field -> OBJECT_IDENTIFIER COLON type SEMICOLON .

    CLASS           reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    TYPE_IDENTIFIER reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    OBJECT_IDENTIFIER reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    WHILE           reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    LET             reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    NOT             reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    MINUS           reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    ISNULL          reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    NEW             reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    SELF            reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    LPAR            reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    error           reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    IF              reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    LBRACE          reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    INTEGER_LITERAL reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    string_literal  reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    TRUE            reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    FALSE           reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    $end            reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)
    RBRACE          reduce using rule 18 (field -> OBJECT_IDENTIFIER COLON type SEMICOLON .)


state 102

    (19) field -> OBJECT_IDENTIFIER COLON type ASSIGN . expression SEMICOLON
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 125
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 103

    (42) expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    CLASS           reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    TYPE_IDENTIFIER reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    OBJECT_IDENTIFIER reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    WHILE           reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    LET             reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    NOT             reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    ISNULL          reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    NEW             reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    SELF            reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    LPAR            reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    error           reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    IF              reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    LBRACE          reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    INTEGER_LITERAL reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    string_literal  reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    TRUE            reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    FALSE           reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    $end            reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    RPAR            reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    THEN            reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    DO              reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    COMMA           reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    RBRACE          reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    SEMICOLON       reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    IN              reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    ELSE            reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47

  ! PLUS            [ reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .) ]
  ! MINUS           [ reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .) ]
  ! TIMES           [ reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .) ]
  ! DIV             [ reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .) ]
  ! EQUAL           [ reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .) ]
  ! LOWER_EQUAL     [ reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .) ]
  ! LOWER           [ reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .) ]
  ! POW             [ reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .) ]
  ! AND             [ reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .) ]
  ! DOT             [ reduce using rule 42 (expression -> OBJECT_IDENTIFIER ASSIGN get_type expression .) ]


state 104

    (30) formal -> OBJECT_IDENTIFIER . COLON type

    COLON           shift and go to state 126


state 105

    (20) method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals . RPAR COLON type block
    (28) formals -> formals . COMMA formal

    RPAR            shift and go to state 127
    COMMA           shift and go to state 128


state 106

    (27) formals -> formal .

    RPAR            reduce using rule 27 (formals -> formal .)
    COMMA           reduce using rule 27 (formals -> formal .)


state 107

    (56) expression -> OBJECT_IDENTIFIER LPAR args RPAR .

    PLUS            reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    MINUS           reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    TIMES           reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    DIV             reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    EQUAL           reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    LOWER_EQUAL     reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    LOWER           reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    POW             reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    AND             reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    DOT             reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    CLASS           reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    TYPE_IDENTIFIER reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    OBJECT_IDENTIFIER reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    WHILE           reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    LET             reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    NOT             reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    ISNULL          reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    NEW             reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    SELF            reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    LPAR            reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    error           reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    IF              reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    LBRACE          reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    INTEGER_LITERAL reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    string_literal  reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    TRUE            reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    FALSE           reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    $end            reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    RPAR            reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    THEN            reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    DO              reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    COMMA           reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    RBRACE          reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    SEMICOLON       reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    IN              reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)
    ELSE            reduce using rule 56 (expression -> OBJECT_IDENTIFIER LPAR args RPAR .)


state 108

    (69) args -> args COMMA . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 129
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 109

    (36) expression -> new_variables_scope IF expression THEN . expression
    (37) expression -> new_variables_scope IF expression THEN . expression ELSE expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    new_variables_scope            shift and go to state 12
    expression                     shift and go to state 130
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 110

    (68) expression -> IF expression THEN expression . SEMICOLON error
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    SEMICOLON       shift and go to state 131
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47


state 111

    (38) expression -> WHILE expression DO expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for LOWER_EQUAL resolved as shift
  ! shift/reduce conflict for LOWER resolved as shift
  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
    CLASS           reduce using rule 38 (expression -> WHILE expression DO expression .)
    TYPE_IDENTIFIER reduce using rule 38 (expression -> WHILE expression DO expression .)
    OBJECT_IDENTIFIER reduce using rule 38 (expression -> WHILE expression DO expression .)
    WHILE           reduce using rule 38 (expression -> WHILE expression DO expression .)
    LET             reduce using rule 38 (expression -> WHILE expression DO expression .)
    NOT             reduce using rule 38 (expression -> WHILE expression DO expression .)
    ISNULL          reduce using rule 38 (expression -> WHILE expression DO expression .)
    NEW             reduce using rule 38 (expression -> WHILE expression DO expression .)
    SELF            reduce using rule 38 (expression -> WHILE expression DO expression .)
    LPAR            reduce using rule 38 (expression -> WHILE expression DO expression .)
    error           reduce using rule 38 (expression -> WHILE expression DO expression .)
    IF              reduce using rule 38 (expression -> WHILE expression DO expression .)
    LBRACE          reduce using rule 38 (expression -> WHILE expression DO expression .)
    INTEGER_LITERAL reduce using rule 38 (expression -> WHILE expression DO expression .)
    string_literal  reduce using rule 38 (expression -> WHILE expression DO expression .)
    TRUE            reduce using rule 38 (expression -> WHILE expression DO expression .)
    FALSE           reduce using rule 38 (expression -> WHILE expression DO expression .)
    $end            reduce using rule 38 (expression -> WHILE expression DO expression .)
    RPAR            reduce using rule 38 (expression -> WHILE expression DO expression .)
    THEN            reduce using rule 38 (expression -> WHILE expression DO expression .)
    DO              reduce using rule 38 (expression -> WHILE expression DO expression .)
    COMMA           reduce using rule 38 (expression -> WHILE expression DO expression .)
    RBRACE          reduce using rule 38 (expression -> WHILE expression DO expression .)
    SEMICOLON       reduce using rule 38 (expression -> WHILE expression DO expression .)
    IN              reduce using rule 38 (expression -> WHILE expression DO expression .)
    ELSE            reduce using rule 38 (expression -> WHILE expression DO expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47

  ! PLUS            [ reduce using rule 38 (expression -> WHILE expression DO expression .) ]
  ! MINUS           [ reduce using rule 38 (expression -> WHILE expression DO expression .) ]
  ! TIMES           [ reduce using rule 38 (expression -> WHILE expression DO expression .) ]
  ! DIV             [ reduce using rule 38 (expression -> WHILE expression DO expression .) ]
  ! EQUAL           [ reduce using rule 38 (expression -> WHILE expression DO expression .) ]
  ! LOWER_EQUAL     [ reduce using rule 38 (expression -> WHILE expression DO expression .) ]
  ! LOWER           [ reduce using rule 38 (expression -> WHILE expression DO expression .) ]
  ! POW             [ reduce using rule 38 (expression -> WHILE expression DO expression .) ]
  ! AND             [ reduce using rule 38 (expression -> WHILE expression DO expression .) ]
  ! DOT             [ reduce using rule 38 (expression -> WHILE expression DO expression .) ]


state 112

    (39) expression -> LET let_type IN expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for LOWER_EQUAL resolved as shift
  ! shift/reduce conflict for LOWER resolved as shift
  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
    CLASS           reduce using rule 39 (expression -> LET let_type IN expression .)
    TYPE_IDENTIFIER reduce using rule 39 (expression -> LET let_type IN expression .)
    OBJECT_IDENTIFIER reduce using rule 39 (expression -> LET let_type IN expression .)
    WHILE           reduce using rule 39 (expression -> LET let_type IN expression .)
    LET             reduce using rule 39 (expression -> LET let_type IN expression .)
    NOT             reduce using rule 39 (expression -> LET let_type IN expression .)
    ISNULL          reduce using rule 39 (expression -> LET let_type IN expression .)
    NEW             reduce using rule 39 (expression -> LET let_type IN expression .)
    SELF            reduce using rule 39 (expression -> LET let_type IN expression .)
    LPAR            reduce using rule 39 (expression -> LET let_type IN expression .)
    error           reduce using rule 39 (expression -> LET let_type IN expression .)
    IF              reduce using rule 39 (expression -> LET let_type IN expression .)
    LBRACE          reduce using rule 39 (expression -> LET let_type IN expression .)
    INTEGER_LITERAL reduce using rule 39 (expression -> LET let_type IN expression .)
    string_literal  reduce using rule 39 (expression -> LET let_type IN expression .)
    TRUE            reduce using rule 39 (expression -> LET let_type IN expression .)
    FALSE           reduce using rule 39 (expression -> LET let_type IN expression .)
    $end            reduce using rule 39 (expression -> LET let_type IN expression .)
    RPAR            reduce using rule 39 (expression -> LET let_type IN expression .)
    THEN            reduce using rule 39 (expression -> LET let_type IN expression .)
    DO              reduce using rule 39 (expression -> LET let_type IN expression .)
    COMMA           reduce using rule 39 (expression -> LET let_type IN expression .)
    RBRACE          reduce using rule 39 (expression -> LET let_type IN expression .)
    SEMICOLON       reduce using rule 39 (expression -> LET let_type IN expression .)
    IN              reduce using rule 39 (expression -> LET let_type IN expression .)
    ELSE            reduce using rule 39 (expression -> LET let_type IN expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47

  ! PLUS            [ reduce using rule 39 (expression -> LET let_type IN expression .) ]
  ! MINUS           [ reduce using rule 39 (expression -> LET let_type IN expression .) ]
  ! TIMES           [ reduce using rule 39 (expression -> LET let_type IN expression .) ]
  ! DIV             [ reduce using rule 39 (expression -> LET let_type IN expression .) ]
  ! EQUAL           [ reduce using rule 39 (expression -> LET let_type IN expression .) ]
  ! LOWER_EQUAL     [ reduce using rule 39 (expression -> LET let_type IN expression .) ]
  ! LOWER           [ reduce using rule 39 (expression -> LET let_type IN expression .) ]
  ! POW             [ reduce using rule 39 (expression -> LET let_type IN expression .) ]
  ! AND             [ reduce using rule 39 (expression -> LET let_type IN expression .) ]
  ! DOT             [ reduce using rule 39 (expression -> LET let_type IN expression .) ]


state 113

    (40) expression -> LET let_type ASSIGN expression . IN expression
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    IN              shift and go to state 132
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47


state 114

    (41) let_type -> OBJECT_IDENTIFIER COLON type .

    IN              reduce using rule 41 (let_type -> OBJECT_IDENTIFIER COLON type .)
    ASSIGN          reduce using rule 41 (let_type -> OBJECT_IDENTIFIER COLON type .)


state 115

    (31) block -> LBRACE new_variables_scope inblock RBRACE .

    CLASS           reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    TYPE_IDENTIFIER reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    OBJECT_IDENTIFIER reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    WHILE           reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    LET             reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    NOT             reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    MINUS           reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    ISNULL          reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    NEW             reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    SELF            reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    LPAR            reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    error           reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    IF              reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    LBRACE          reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    INTEGER_LITERAL reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    string_literal  reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    TRUE            reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    FALSE           reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    $end            reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    PLUS            reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    TIMES           reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    DIV             reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    EQUAL           reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    LOWER_EQUAL     reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    LOWER           reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    POW             reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    AND             reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    DOT             reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    RPAR            reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    THEN            reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    DO              reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    COMMA           reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    RBRACE          reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    SEMICOLON       reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    IN              reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)
    ELSE            reduce using rule 31 (block -> LBRACE new_variables_scope inblock RBRACE .)


state 116

    (32) inblock -> inblock SEMICOLON . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 133
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 117

    (35) inblock -> inblock error .

    RBRACE          reduce using rule 35 (inblock -> inblock error .)
    SEMICOLON       reduce using rule 35 (inblock -> inblock error .)
    error           reduce using rule 35 (inblock -> inblock error .)


state 118

    (11) class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .

    CLASS           reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    TYPE_IDENTIFIER reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    OBJECT_IDENTIFIER reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    WHILE           reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    LET             reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    NOT             reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    MINUS           reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    ISNULL          reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    NEW             reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    SELF            reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    LPAR            reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    error           reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    IF              reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    LBRACE          reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    INTEGER_LITERAL reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    string_literal  reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    TRUE            reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    FALSE           reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)
    $end            reduce using rule 11 (class -> CLASS new_class_scope EXTENDS TYPE_IDENTIFIER class-body .)


state 119

    (13) class-body -> LBRACE class-body-in RBRACE .

    CLASS           reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    TYPE_IDENTIFIER reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    OBJECT_IDENTIFIER reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    WHILE           reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    LET             reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    NOT             reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    MINUS           reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    ISNULL          reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    NEW             reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    SELF            reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    LPAR            reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    error           reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    IF              reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    LBRACE          reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    INTEGER_LITERAL reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    string_literal  reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    TRUE            reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    FALSE           reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)
    $end            reduce using rule 13 (class-body -> LBRACE class-body-in RBRACE .)


state 120

    (14) class-body -> LBRACE class-body-in error .

    CLASS           reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    TYPE_IDENTIFIER reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    OBJECT_IDENTIFIER reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    WHILE           reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    LET             reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    NOT             reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    MINUS           reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    ISNULL          reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    NEW             reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    SELF            reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    LPAR            reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    error           reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    IF              reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    LBRACE          reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    INTEGER_LITERAL reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    string_literal  reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    TRUE            reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    FALSE           reduce using rule 14 (class-body -> LBRACE class-body-in error .)
    $end            reduce using rule 14 (class-body -> LBRACE class-body-in error .)


state 121

    (15) class-body-in -> class-body-in field .

    RBRACE          reduce using rule 15 (class-body-in -> class-body-in field .)
    error           reduce using rule 15 (class-body-in -> class-body-in field .)
    OBJECT_IDENTIFIER reduce using rule 15 (class-body-in -> class-body-in field .)


state 122

    (16) class-body-in -> class-body-in method .

    RBRACE          reduce using rule 16 (class-body-in -> class-body-in method .)
    error           reduce using rule 16 (class-body-in -> class-body-in method .)
    OBJECT_IDENTIFIER reduce using rule 16 (class-body-in -> class-body-in method .)


state 123

    (18) field -> OBJECT_IDENTIFIER . COLON type SEMICOLON
    (19) field -> OBJECT_IDENTIFIER . COLON type ASSIGN expression SEMICOLON
    (20) method -> OBJECT_IDENTIFIER . new_variables_scope LPAR formals RPAR COLON type block
    (21) new_variables_scope -> .

    COLON           shift and go to state 48
    LPAR            reduce using rule 21 (new_variables_scope -> .)

    new_variables_scope            shift and go to state 50

state 124

    (57) expression -> expression DOT OBJECT_IDENTIFIER LPAR args . RPAR
    (69) args -> args . COMMA expression

    RPAR            shift and go to state 134
    COMMA           shift and go to state 108


state 125

    (19) field -> OBJECT_IDENTIFIER COLON type ASSIGN expression . SEMICOLON
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    SEMICOLON       shift and go to state 135
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47


state 126

    (30) formal -> OBJECT_IDENTIFIER COLON . type
    (22) type -> . TYPE_IDENTIFIER
    (23) type -> . INT32
    (24) type -> . BOOL
    (25) type -> . STRING
    (26) type -> . UNIT

    TYPE_IDENTIFIER shift and go to state 79
    INT32           shift and go to state 80
    BOOL            shift and go to state 81
    STRING          shift and go to state 82
    UNIT            shift and go to state 83

    type                           shift and go to state 136

state 127

    (20) method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR . COLON type block

    COLON           shift and go to state 137


state 128

    (28) formals -> formals COMMA . formal
    (30) formal -> . OBJECT_IDENTIFIER COLON type

    OBJECT_IDENTIFIER shift and go to state 104

    formal                         shift and go to state 138

state 129

    (69) args -> args COMMA expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    RPAR            reduce using rule 69 (args -> args COMMA expression .)
    COMMA           reduce using rule 69 (args -> args COMMA expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47


state 130

    (36) expression -> new_variables_scope IF expression THEN expression .
    (37) expression -> new_variables_scope IF expression THEN expression . ELSE expression
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for LOWER_EQUAL resolved as shift
  ! shift/reduce conflict for LOWER resolved as shift
  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
    CLASS           reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    TYPE_IDENTIFIER reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    OBJECT_IDENTIFIER reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    WHILE           reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    LET             reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    NOT             reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    ISNULL          reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    NEW             reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    SELF            reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    LPAR            reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    error           reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    IF              reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    LBRACE          reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    INTEGER_LITERAL reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    string_literal  reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    TRUE            reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    FALSE           reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    $end            reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    RPAR            reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    THEN            reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    DO              reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    COMMA           reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    RBRACE          reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    SEMICOLON       reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    IN              reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .)
    ELSE            shift and go to state 139
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47

  ! PLUS            [ reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .) ]
  ! MINUS           [ reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .) ]
  ! TIMES           [ reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .) ]
  ! DIV             [ reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .) ]
  ! EQUAL           [ reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .) ]
  ! LOWER_EQUAL     [ reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .) ]
  ! LOWER           [ reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .) ]
  ! POW             [ reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .) ]
  ! AND             [ reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .) ]
  ! DOT             [ reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .) ]
  ! ELSE            [ reduce using rule 36 (expression -> new_variables_scope IF expression THEN expression .) ]


state 131

    (68) expression -> IF expression THEN expression SEMICOLON . error

    error           shift and go to state 140


state 132

    (40) expression -> LET let_type ASSIGN expression IN . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    expression                     shift and go to state 141
    new_variables_scope            shift and go to state 12
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 133

    (32) inblock -> inblock SEMICOLON expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

    RBRACE          reduce using rule 32 (inblock -> inblock SEMICOLON expression .)
    SEMICOLON       reduce using rule 32 (inblock -> inblock SEMICOLON expression .)
    error           reduce using rule 32 (inblock -> inblock SEMICOLON expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47


state 134

    (57) expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .

    PLUS            reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    MINUS           reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    TIMES           reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    DIV             reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    EQUAL           reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    LOWER_EQUAL     reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    LOWER           reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    POW             reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    AND             reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    DOT             reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    CLASS           reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    TYPE_IDENTIFIER reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    OBJECT_IDENTIFIER reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    WHILE           reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    LET             reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    NOT             reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    ISNULL          reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    NEW             reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    SELF            reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    LPAR            reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    error           reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    IF              reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    LBRACE          reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    INTEGER_LITERAL reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    string_literal  reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    TRUE            reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    FALSE           reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    $end            reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    RPAR            reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    THEN            reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    DO              reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    COMMA           reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    RBRACE          reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    SEMICOLON       reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    IN              reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)
    ELSE            reduce using rule 57 (expression -> expression DOT OBJECT_IDENTIFIER LPAR args RPAR .)


state 135

    (19) field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .

    CLASS           reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    TYPE_IDENTIFIER reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    OBJECT_IDENTIFIER reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    LET             reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    ISNULL          reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    NEW             reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    SELF            reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    LPAR            reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    error           reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    IF              reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    INTEGER_LITERAL reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    string_literal  reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    $end            reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 19 (field -> OBJECT_IDENTIFIER COLON type ASSIGN expression SEMICOLON .)


state 136

    (30) formal -> OBJECT_IDENTIFIER COLON type .

    RPAR            reduce using rule 30 (formal -> OBJECT_IDENTIFIER COLON type .)
    COMMA           reduce using rule 30 (formal -> OBJECT_IDENTIFIER COLON type .)


state 137

    (20) method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON . type block
    (22) type -> . TYPE_IDENTIFIER
    (23) type -> . INT32
    (24) type -> . BOOL
    (25) type -> . STRING
    (26) type -> . UNIT

    TYPE_IDENTIFIER shift and go to state 79
    INT32           shift and go to state 80
    BOOL            shift and go to state 81
    STRING          shift and go to state 82
    UNIT            shift and go to state 83

    type                           shift and go to state 142

state 138

    (28) formals -> formals COMMA formal .

    RPAR            reduce using rule 28 (formals -> formals COMMA formal .)
    COMMA           reduce using rule 28 (formals -> formals COMMA formal .)


state 139

    (37) expression -> new_variables_scope IF expression THEN expression ELSE . expression
    (36) expression -> . new_variables_scope IF expression THEN expression
    (37) expression -> . new_variables_scope IF expression THEN expression ELSE expression
    (38) expression -> . WHILE expression DO expression
    (39) expression -> . LET let_type IN expression
    (40) expression -> . LET let_type ASSIGN expression IN expression
    (42) expression -> . OBJECT_IDENTIFIER ASSIGN get_type expression
    (44) expression -> . NOT expression
    (45) expression -> . MINUS expression
    (46) expression -> . ISNULL expression
    (47) expression -> . expression PLUS expression
    (48) expression -> . expression MINUS expression
    (49) expression -> . expression TIMES expression
    (50) expression -> . expression DIV expression
    (51) expression -> . expression EQUAL expression
    (52) expression -> . expression LOWER_EQUAL expression
    (53) expression -> . expression LOWER expression
    (54) expression -> . expression POW expression
    (55) expression -> . expression AND expression
    (56) expression -> . OBJECT_IDENTIFIER LPAR args RPAR
    (57) expression -> . expression DOT OBJECT_IDENTIFIER LPAR args RPAR
    (58) expression -> . NEW TYPE_IDENTIFIER
    (59) expression -> . OBJECT_IDENTIFIER
    (60) expression -> . SELF
    (61) expression -> . literal
    (62) expression -> . LPAR RPAR
    (63) expression -> . LPAR expression RPAR
    (64) expression -> . LPAR expression error
    (65) expression -> . error expression RPAR
    (66) expression -> . block
    (67) expression -> . error
    (68) expression -> . IF expression THEN expression SEMICOLON error
    (21) new_variables_scope -> .
    (72) literal -> . literal_integer
    (73) literal -> . literal_string
    (74) literal -> . boolean-literal
    (31) block -> . LBRACE new_variables_scope inblock RBRACE
    (76) literal_integer -> . INTEGER_LITERAL
    (75) literal_string -> . string_literal
    (77) boolean-literal -> . TRUE
    (78) boolean-literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
    WHILE           shift and go to state 15
    LET             shift and go to state 16
    OBJECT_IDENTIFIER shift and go to state 36
    NOT             shift and go to state 17
    MINUS           shift and go to state 18
    ISNULL          shift and go to state 19
    NEW             shift and go to state 20
    SELF            shift and go to state 21
    LPAR            shift and go to state 13
    error           shift and go to state 7
    IF              shift and go to state 14
    LBRACE          shift and go to state 23
    INTEGER_LITERAL shift and go to state 27
    string_literal  shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30

  ! IF              [ reduce using rule 21 (new_variables_scope -> .) ]

    new_variables_scope            shift and go to state 12
    expression                     shift and go to state 143
    literal                        shift and go to state 22
    block                          shift and go to state 37
    literal_integer                shift and go to state 24
    literal_string                 shift and go to state 25
    boolean-literal                shift and go to state 26

state 140

    (68) expression -> IF expression THEN expression SEMICOLON error .

    PLUS            reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    MINUS           reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    TIMES           reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    DIV             reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    EQUAL           reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    LOWER_EQUAL     reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    LOWER           reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    POW             reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    AND             reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    DOT             reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    CLASS           reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    TYPE_IDENTIFIER reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    OBJECT_IDENTIFIER reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    WHILE           reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    LET             reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    NOT             reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    ISNULL          reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    NEW             reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    SELF            reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    LPAR            reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    error           reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    IF              reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    LBRACE          reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    INTEGER_LITERAL reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    string_literal  reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    TRUE            reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    FALSE           reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    $end            reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    RPAR            reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    THEN            reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    DO              reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    COMMA           reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    RBRACE          reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    SEMICOLON       reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    IN              reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)
    ELSE            reduce using rule 68 (expression -> IF expression THEN expression SEMICOLON error .)


state 141

    (40) expression -> LET let_type ASSIGN expression IN expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for LOWER_EQUAL resolved as shift
  ! shift/reduce conflict for LOWER resolved as shift
  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
    CLASS           reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    TYPE_IDENTIFIER reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    OBJECT_IDENTIFIER reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    WHILE           reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    LET             reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    NOT             reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    ISNULL          reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    NEW             reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    SELF            reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    LPAR            reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    error           reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    IF              reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    LBRACE          reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    INTEGER_LITERAL reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    string_literal  reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    TRUE            reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    FALSE           reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    $end            reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    RPAR            reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    THEN            reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    DO              reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    COMMA           reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    RBRACE          reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    SEMICOLON       reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    IN              reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    ELSE            reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47

  ! PLUS            [ reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .) ]
  ! MINUS           [ reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .) ]
  ! TIMES           [ reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .) ]
  ! DIV             [ reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .) ]
  ! EQUAL           [ reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .) ]
  ! LOWER_EQUAL     [ reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .) ]
  ! LOWER           [ reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .) ]
  ! POW             [ reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .) ]
  ! AND             [ reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .) ]
  ! DOT             [ reduce using rule 40 (expression -> LET let_type ASSIGN expression IN expression .) ]


state 142

    (20) method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type . block
    (31) block -> . LBRACE new_variables_scope inblock RBRACE

    LBRACE          shift and go to state 23

    block                          shift and go to state 144

state 143

    (37) expression -> new_variables_scope IF expression THEN expression ELSE expression .
    (47) expression -> expression . PLUS expression
    (48) expression -> expression . MINUS expression
    (49) expression -> expression . TIMES expression
    (50) expression -> expression . DIV expression
    (51) expression -> expression . EQUAL expression
    (52) expression -> expression . LOWER_EQUAL expression
    (53) expression -> expression . LOWER expression
    (54) expression -> expression . POW expression
    (55) expression -> expression . AND expression
    (57) expression -> expression . DOT OBJECT_IDENTIFIER LPAR args RPAR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for LOWER_EQUAL resolved as shift
  ! shift/reduce conflict for LOWER resolved as shift
  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
    CLASS           reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    TYPE_IDENTIFIER reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    OBJECT_IDENTIFIER reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    WHILE           reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    LET             reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    NOT             reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    ISNULL          reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    NEW             reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    SELF            reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    LPAR            reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    error           reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    IF              reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    LBRACE          reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    INTEGER_LITERAL reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    string_literal  reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    TRUE            reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    FALSE           reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    $end            reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    RPAR            reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    THEN            reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    DO              reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    COMMA           reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    RBRACE          reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    SEMICOLON       reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    IN              reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    ELSE            reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIV             shift and go to state 41
    EQUAL           shift and go to state 42
    LOWER_EQUAL     shift and go to state 43
    LOWER           shift and go to state 44
    POW             shift and go to state 45
    AND             shift and go to state 46
    DOT             shift and go to state 47

  ! PLUS            [ reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .) ]
  ! MINUS           [ reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .) ]
  ! TIMES           [ reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .) ]
  ! DIV             [ reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .) ]
  ! EQUAL           [ reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .) ]
  ! LOWER_EQUAL     [ reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .) ]
  ! LOWER           [ reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .) ]
  ! POW             [ reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .) ]
  ! AND             [ reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .) ]
  ! DOT             [ reduce using rule 37 (expression -> new_variables_scope IF expression THEN expression ELSE expression .) ]


state 144

    (20) method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .

    CLASS           reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    TYPE_IDENTIFIER reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    OBJECT_IDENTIFIER reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    WHILE           reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    LET             reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    NOT             reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    MINUS           reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    ISNULL          reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    NEW             reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    SELF            reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    LPAR            reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    error           reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    IF              reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    LBRACE          reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    INTEGER_LITERAL reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    string_literal  reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    TRUE            reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    FALSE           reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    $end            reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)
    RBRACE          reduce using rule 20 (method -> OBJECT_IDENTIFIER new_variables_scope LPAR formals RPAR COLON type block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 7 resolved as shift
WARNING: shift/reduce conflict for LET in state 7 resolved as shift
WARNING: shift/reduce conflict for OBJECT_IDENTIFIER in state 7 resolved as shift
WARNING: shift/reduce conflict for NOT in state 7 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 7 resolved as shift
WARNING: shift/reduce conflict for ISNULL in state 7 resolved as shift
WARNING: shift/reduce conflict for NEW in state 7 resolved as shift
WARNING: shift/reduce conflict for SELF in state 7 resolved as shift
WARNING: shift/reduce conflict for LPAR in state 7 resolved as shift
WARNING: shift/reduce conflict for error in state 7 resolved as shift
WARNING: shift/reduce conflict for IF in state 7 resolved as shift
WARNING: shift/reduce conflict for IF in state 7 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 7 resolved as shift
WARNING: shift/reduce conflict for INTEGER_LITERAL in state 7 resolved as shift
WARNING: shift/reduce conflict for string_literal in state 7 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 7 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 7 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 8 resolved as shift
WARNING: shift/reduce conflict for LPAR in state 11 resolved as shift
WARNING: shift/reduce conflict for LPAR in state 11 resolved as shift
WARNING: shift/reduce conflict for IF in state 13 resolved as shift
WARNING: shift/reduce conflict for IF in state 14 resolved as shift
WARNING: shift/reduce conflict for IF in state 15 resolved as shift
WARNING: shift/reduce conflict for IF in state 17 resolved as shift
WARNING: shift/reduce conflict for IF in state 18 resolved as shift
WARNING: shift/reduce conflict for IF in state 19 resolved as shift
WARNING: shift/reduce conflict for LPAR in state 36 resolved as shift
WARNING: shift/reduce conflict for IF in state 38 resolved as shift
WARNING: shift/reduce conflict for IF in state 39 resolved as shift
WARNING: shift/reduce conflict for IF in state 40 resolved as shift
WARNING: shift/reduce conflict for IF in state 41 resolved as shift
WARNING: shift/reduce conflict for IF in state 42 resolved as shift
WARNING: shift/reduce conflict for IF in state 43 resolved as shift
WARNING: shift/reduce conflict for IF in state 44 resolved as shift
WARNING: shift/reduce conflict for IF in state 45 resolved as shift
WARNING: shift/reduce conflict for IF in state 46 resolved as shift
WARNING: shift/reduce conflict for IF in state 51 resolved as shift
WARNING: shift/reduce conflict for IF in state 52 resolved as shift
WARNING: shift/reduce conflict for error in state 63 resolved as shift
WARNING: shift/reduce conflict for IF in state 63 resolved as shift
WARNING: shift/reduce conflict for IF in state 84 resolved as shift
WARNING: shift/reduce conflict for IF in state 91 resolved as shift
WARNING: shift/reduce conflict for IF in state 92 resolved as shift
WARNING: shift/reduce conflict for IF in state 93 resolved as shift
WARNING: shift/reduce conflict for IF in state 94 resolved as shift
WARNING: shift/reduce conflict for IF in state 100 resolved as shift
WARNING: shift/reduce conflict for IF in state 102 resolved as shift
WARNING: shift/reduce conflict for IF in state 108 resolved as shift
WARNING: shift/reduce conflict for IF in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 111 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 111 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 111 resolved as shift
WARNING: shift/reduce conflict for DIV in state 111 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 111 resolved as shift
WARNING: shift/reduce conflict for LOWER_EQUAL in state 111 resolved as shift
WARNING: shift/reduce conflict for LOWER in state 111 resolved as shift
WARNING: shift/reduce conflict for POW in state 111 resolved as shift
WARNING: shift/reduce conflict for AND in state 111 resolved as shift
WARNING: shift/reduce conflict for DOT in state 111 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 112 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 112 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 112 resolved as shift
WARNING: shift/reduce conflict for DIV in state 112 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 112 resolved as shift
WARNING: shift/reduce conflict for LOWER_EQUAL in state 112 resolved as shift
WARNING: shift/reduce conflict for LOWER in state 112 resolved as shift
WARNING: shift/reduce conflict for POW in state 112 resolved as shift
WARNING: shift/reduce conflict for AND in state 112 resolved as shift
WARNING: shift/reduce conflict for DOT in state 112 resolved as shift
WARNING: shift/reduce conflict for IF in state 116 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 130 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 130 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 130 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 130 resolved as shift
WARNING: shift/reduce conflict for DIV in state 130 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 130 resolved as shift
WARNING: shift/reduce conflict for LOWER_EQUAL in state 130 resolved as shift
WARNING: shift/reduce conflict for LOWER in state 130 resolved as shift
WARNING: shift/reduce conflict for POW in state 130 resolved as shift
WARNING: shift/reduce conflict for AND in state 130 resolved as shift
WARNING: shift/reduce conflict for DOT in state 130 resolved as shift
WARNING: shift/reduce conflict for IF in state 132 resolved as shift
WARNING: shift/reduce conflict for IF in state 139 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 141 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 141 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 141 resolved as shift
WARNING: shift/reduce conflict for DIV in state 141 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 141 resolved as shift
WARNING: shift/reduce conflict for LOWER_EQUAL in state 141 resolved as shift
WARNING: shift/reduce conflict for LOWER in state 141 resolved as shift
WARNING: shift/reduce conflict for POW in state 141 resolved as shift
WARNING: shift/reduce conflict for AND in state 141 resolved as shift
WARNING: shift/reduce conflict for DOT in state 141 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 143 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 143 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 143 resolved as shift
WARNING: shift/reduce conflict for DIV in state 143 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 143 resolved as shift
WARNING: shift/reduce conflict for LOWER_EQUAL in state 143 resolved as shift
WARNING: shift/reduce conflict for LOWER in state 143 resolved as shift
WARNING: shift/reduce conflict for POW in state 143 resolved as shift
WARNING: shift/reduce conflict for AND in state 143 resolved as shift
WARNING: shift/reduce conflict for DOT in state 143 resolved as shift
WARNING: reduce/reduce conflict in state 10 resolved using rule (class -> block)
WARNING: rejected rule (expression -> block) in state 10
